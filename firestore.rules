rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // üÜï PHASE 2.1: Custom Claims Support mit Fallback
    // ============================================

    function isAuthenticated() {
      return request.auth != null;
    }

    // üÜï Priority 1: Custom Claims, Priority 2: Firestore Fallback
    // ‚ö†Ô∏è SIMPLIFIED: Avoid multiple get() calls to prevent Evaluation Errors
    function getUserRole() {
      // Try Custom Claims first (faster, no Firestore read)
      return (request.auth.token != null && request.auth.token.role != null)
        ? request.auth.token.role
        : (exists(/databases/$(database)/documents/users/$(request.auth.uid))
            ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role
            : null);
    }

    // Status bleibt Firestore-basiert (Claims haben kein 'status' field)
    // ‚ö†Ô∏è SIMPLIFIED: Single get() call with fallback
    function getUserStatus() {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid))
        ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.status
        : 'active';  // Fallback for Partners or E2E tests without users/{uid}
    }

    function isAdmin() {
      return isAuthenticated() && (getUserRole() == 'admin' || getUserRole() == 'werkstatt' || getUserRole() == 'superadmin');
    }

    function isSuperAdmin() {
      return isAuthenticated() && getUserRole() == 'superadmin';
    }

    function isMitarbeiter() {
      // Check if a mitarbeiter is selected (via Custom Claims)
      // This allows werkstatt users to act as mitarbeiter while keeping werkstatt role
      return isAuthenticated() && request.auth.token.selectedMitarbeiterId != null;
    }

    function isPartner() {
      return isAuthenticated() && getUserRole() == 'partner';
    }

    function isKunde() {
      return isAuthenticated() && getUserRole() == 'kunde';
    }

    function isSteuerberater() {
      return isAuthenticated() && getUserRole() == 'steuerberater';
    }

    function isActive() {
      return getUserStatus() == 'active';
    }

    // üÜï Check ownership via Custom Claims partnerId OR uid
    function isOwner(partnerId) {
      // Priority 1: Custom Claims partnerId, Priority 2: Fallback to uid
      return isAuthenticated() &&
        ((request.auth.token != null && request.auth.token.partnerId != null)
          ? request.auth.token.partnerId == partnerId
          : request.auth.uid == partnerId);
    }

    // ============================================
    // üî• BONUS COLLECTIONS - MOVED TO TOP (FIX #53)
    // ============================================
    // CRITICAL: These rules MUST be at the TOP to prevent pattern collisions
    // Other wildcard patterns (/{chatCollection}/{id}, /{partnersCollection}/{id})
    // were matching BEFORE our bonus rules and blocking access!
    //
    // Strategy: Evaluate bonus rules FIRST, before ANY other wildcard patterns

    // MULTI-TENANT BONUS COLLECTIONS (bonusAuszahlungen_mosbach, bonusAuszahlungen_heidelberg, etc.)
    // üîí SECURED: Role-based access control (Bug #3 Fix - Nov 2025)
    match /{bonusCollection}/{bonusId} {
      // Admin: Full read/write access (Bonus-Verwaltung)
      allow read, write: if bonusCollection.matches('bonusAuszahlungen_.+') && isAdmin();

      // Mitarbeiter: Read-only access
      allow read: if bonusCollection.matches('bonusAuszahlungen_.+')
                  && isMitarbeiter() && isActive();

      // Partner: Read own bonuses + Create new
      allow read: if bonusCollection.matches('bonusAuszahlungen_.+')
                  && request.auth != null
                  && resource.data.partnerEmail == request.auth.token.email;
      allow create: if bonusCollection.matches('bonusAuszahlungen_.+')
                    && request.auth != null;
    }

    // ============================================
    // üìö WISSENSDATENBANK (Knowledge Base) - NEW 2025-11-08
    // ============================================
    // Three collections for guidelines, announcements, and shift handovers
    // Multi-tenant pattern: guidelines_mosbach, announcements_mosbach, shift_handovers_mosbach, etc.

    // 1. GUIDELINES COLLECTION (SOPs, Richtlinien, Prozesse)
    match /{guidelinesCollection}/{guidelineId} {
      // üß™ Seeding Support: Allow any authenticated user to create/read
      // CRITICAL: MUST BE FIRST to enable seeding without admin role
      allow read, create: if request.auth != null
                  && guidelinesCollection.matches('guidelines_.+');

      // Update/Delete: Only admins can modify existing guidelines
      allow update, delete: if isAdmin()
                  && guidelinesCollection.matches('guidelines_.+');
    }

    // 2. ANNOUNCEMENTS COLLECTION (Team communication, updates)
    match /{announcementsCollection}/{announcementId} {
      // üß™ Seeding Support: Allow any authenticated user to create/read
      // CRITICAL: MUST BE FIRST to enable seeding without admin role
      allow read, create: if request.auth != null
                  && announcementsCollection.matches('announcements_.+');

      // Update/Delete: Only admins can modify existing announcements
      allow update, delete: if isAdmin()
                  && announcementsCollection.matches('announcements_.+');

      // Update reactions and comments: All authenticated users
      allow update: if isAuthenticated()
                  && announcementsCollection.matches('announcements_.+')
                  && (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions', 'comments', 'readBy']));
    }

    // 3. SHIFT HANDOVERS COLLECTION (Schicht√ºbergaben)
    match /{handoversCollection}/{handoverId} {
      // üß™ Seeding Support: Allow any authenticated user to create/read
      // CRITICAL: MUST BE FIRST to enable seeding without admin role
      allow read, create: if request.auth != null
                  && handoversCollection.matches('shift_handovers_.+');

      // Update/Delete: Only admins can edit/delete handovers
      allow update, delete: if isAdmin()
                  && handoversCollection.matches('shift_handovers_.+');
    }

    // 4. CATEGORIES COLLECTION (Custom Categories for Guidelines & Announcements)
    match /{categoriesCollection}/{categoryId} {
      // Read: All authenticated users can read categories
      allow read: if isAuthenticated()
                  && categoriesCollection.matches('categories_.+');

      // Create/Update/Delete: Only admins can manage categories
      allow create, update, delete: if isAdmin()
                  && categoriesCollection.matches('categories_.+')
                  && request.resource.data.keys().hasAll([
                      'name', 'emoji', 'color', 'type', 'isDefault', 'createdAt', 'createdBy'
                  ]);
    }

    // 5. DEMONTAGE-ANLEITUNGEN COLLECTION (Step-by-Step Disassembly Guides) - NEW 2025-11-26
    // Multi-tenant pattern: demontage_anleitungen_mosbach, demontage_anleitungen_heidelberg, etc.
    match /{demontageCollection}/{anleitungId} {
      // üß™ Seeding Support: Allow any authenticated user to create/read
      // CRITICAL: MUST BE FIRST to enable seeding without admin role
      allow read, create: if request.auth != null
                  && demontageCollection.matches('demontage_anleitungen_.+');

      // Update/Delete: Only admins can modify existing guides
      allow update, delete: if isAdmin()
                  && demontageCollection.matches('demontage_anleitungen_.+');

      // Update view count and readBy: All authenticated users
      allow update: if isAuthenticated()
                  && demontageCollection.matches('demontage_anleitungen_.+')
                  && (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount', 'readBy']));
    }

    // ============================================
    // ACTIVE SESSIONS (Multi-Tab Monitoring)
    // ============================================
    // Multi-tenant pattern: activeSessions_mosbach, activeSessions_heidelberg, etc.
    // Tracks active employee logins for real-time dashboard monitoring

    match /{activeSessionsCollection}/{sessionId} {
      // Pattern match for activeSessions_* collections
      allow create: if activeSessionsCollection.matches('activeSessions_.+')
                    && isAuthenticated()
                    && request.resource.data.werkstattId == activeSessionsCollection.split('_')[1]
                    && request.resource.data.status == 'active'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'werkstattId',
                        'loginTime', 'lastActivity', 'status'
                    ]);

      // Mitarbeiter can update their own session (heartbeat)
      allow update: if activeSessionsCollection.matches('activeSessions_.+')
                    && isAuthenticated()
                    && resource.data.mitarbeiterId == request.auth.uid;

      // Mitarbeiter can delete their own session (logout)
      allow delete: if activeSessionsCollection.matches('activeSessions_.+')
                    && isAuthenticated()
                    && resource.data.mitarbeiterId == request.auth.uid;

      // üÜï FIX 2025-11-07: Use Custom Claims for query-compatible access check
      // Werkstatt & Admin can read all sessions (for monitoring dashboard)
      // CRITICAL: Uses request.auth.token (Custom Claims) instead of get()
      // to avoid "Missing or insufficient permissions" during query evaluation
      allow read: if activeSessionsCollection.matches('activeSessions_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                    || request.auth.token.role == 'mitarbeiter'
                  );
    }

    // ============================================
    // SERVICE-SESSIONS COLLECTION (Multi-Tenant)
    // Phase 1.2 - Dienstplan Feature
    // Tracks which services (Lackierung, Mechanik, etc.) each employee is working on
    // ============================================

    match /{serviceSessionsCollection}/{sessionId} {
      // Mitarbeiter can create their own service sessions
      // VALIDATION: Ensures werkstattId matches, mitarbeiterId is current user, status is 'active'
      allow create: if serviceSessionsCollection.matches('serviceSessions_.+')
                    && isAuthenticated()
                    && request.resource.data.werkstattId == serviceSessionsCollection.split('_')[1]
                    && request.resource.data.mitarbeiterId == request.auth.uid
                    && request.resource.data.status == 'active'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'service',
                        'werkstattId', 'loginTime', 'status'
                    ]);

      // Mitarbeiter can read/update their own sessions
      allow read, update: if serviceSessionsCollection.matches('serviceSessions_.+')
                          && isAuthenticated()
                          && resource.data.mitarbeiterId == request.auth.uid;

      // Mitarbeiter can delete their own sessions (logout)
      allow delete: if serviceSessionsCollection.matches('serviceSessions_.+')
                    && isAuthenticated()
                    && resource.data.mitarbeiterId == request.auth.uid;

      // üÜï Use Custom Claims for query-compatible access check
      // Werkstatt & Admin can read all sessions (for monitoring dashboard)
      // CRITICAL: Uses request.auth.token (Custom Claims) instead of get()
      allow read: if serviceSessionsCollection.matches('serviceSessions_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                    || request.auth.token.role == 'mitarbeiter'
                  );
    }

    // ============================================
    // URLAUBS-ANFRAGEN COLLECTION (Multi-Tenant)
    // Phase 2.1 - Dienstplan Feature (Vacation Requests)
    // Mitarbeiter k√∂nnen Urlaub anfragen, Admin kann genehmigen/ablehnen
    // ============================================

    match /{urlaubsAnfragenCollection}/{anfrageId} {
      // Mitarbeiter can create their own vacation requests
      // VALIDATION: Ensures werkstattId matches, mitarbeiterId is current user, status is 'pending'
      // Uses Custom Claims mitarbeiterId (2-Stage Auth: Werkstatt Login ‚Üí Mitarbeiter Selection)
      allow create: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.+')
                    && isAuthenticated()
                    && isMitarbeiter()
                    && isActive()
                    && request.resource.data.werkstattId == urlaubsAnfragenCollection.split('_')[1]
                    && request.resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && request.resource.data.status == 'pending'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'startDatum', 'endDatum',
                        'anzahlTage', 'grund', 'status', 'werkstattId', 'createdAt'
                    ]);

      // Mitarbeiter can read their own requests
      // Uses Custom Claims mitarbeiterId (2-Stage Auth: Werkstatt Login ‚Üí Mitarbeiter Selection)
      allow read: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.+')
                  && isAuthenticated()
                  && isMitarbeiter()
                  && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

      // Werkstatt & Admin can read all requests (for admin panel)
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow read: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                    || getUserRole() == 'werkstatt'
                    || getUserRole() == 'admin'
                    || getUserRole() == 'superadmin'
                  );

      // Admin can update requests (approve/reject)
      // VALIDATION: Only status, bearbeitetVon, bearbeitetAm, ablehnungsgrund can be changed
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow update: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                      || getUserRole() == 'werkstatt'
                      || getUserRole() == 'admin'
                      || getUserRole() == 'superadmin'
                    )
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                        'status', 'bearbeitetVon', 'bearbeitetAm', 'ablehnungsgrund'
                    ])
                    && (
                      request.resource.data.status == 'approved'
                      || request.resource.data.status == 'rejected'
                    );

      // Mitarbeiter can delete their own pending requests
      // USES CUSTOM CLAIMS: request.auth.token.selectedMitarbeiterId
      allow delete: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.+')
                    && isAuthenticated()
                    && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && resource.data.status == 'pending';

      // Admin can delete any request
      allow delete: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );
    }

    // ============================================
    // SCHICHT-TYPEN COLLECTION (Multi-Tenant)
    // Phase 2.2 - Dienstplan Feature (Shift Types)
    // Admin erstellt Schicht-Typen (z.B. Fr√ºhschicht 6-14h, Sp√§tschicht 14-22h)
    // ============================================

    match /{schichtTypenCollection}/{schichtTypId} {
      // Admin/Werkstatt: Full access (CRUD)
      allow create, read, update, delete: if schichtTypenCollection.matches('schichtTypen_.+')
                                          && isAuthenticated()
                                          && (
                                            request.auth.token.role == 'werkstatt'
                                            || request.auth.token.role == 'admin'
                                            || request.auth.token.role == 'superadmin'
                                          );

      // Mitarbeiter: Read-only (k√∂nnen Schicht-Typen sehen)
      allow read: if schichtTypenCollection.matches('schichtTypen_.+')
                  && isMitarbeiter()
                  && isActive();
    }

    // ============================================
    // SCHICHTEN COLLECTION (Multi-Tenant)
    // Phase 2.2 - Dienstplan Feature (Shift Assignments)
    // Admin weist Mitarbeiter zu Schichten zu
    // ============================================

    match /{schichtenCollection}/{schichtId} {
      // Admin/Werkstatt: Full access (CRUD)
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow create, read, update, delete: if schichtenCollection.matches('schichten_.+')
                                          && isAuthenticated()
                                          && (
                                            request.auth.token.role == 'werkstatt'
                                            || request.auth.token.role == 'admin'
                                            || request.auth.token.role == 'superadmin'
                                            || getUserRole() == 'werkstatt'
                                            || getUserRole() == 'admin'
                                            || getUserRole() == 'superadmin'
                                          );

      // RELAXED: Allow werkstatt OR mitarbeiter role to read all schichten
      // This allows SessionStorage-based mitarbeiter sessions (without Custom Claims)
      // to still access schichten via werkstatt role
      allow read: if schichtenCollection.matches('schichten_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'mitarbeiter'
                  );
    }

    // ============================================
    // SCHICHT-W√úNSCHE COLLECTION (Multi-Tenant)
    // Phase 2.2 - Dienstplan Feature (Shift Preferences)
    // Mitarbeiter k√∂nnen W√ºnsche √§u√üern (bevorzugt/nicht verf√ºgbar)
    // ============================================

    match /{schichtWuenscheCollection}/{wunschId} {
      // Mitarbeiter: Create own w√ºnsche
      // VALIDATION: werkstattId match, mitarbeiterId is current user, status is 'pending'
      allow create: if schichtWuenscheCollection.matches('schichtWuensche_.+')
                    && isAuthenticated()
                    && isMitarbeiter()
                    && isActive()
                    && request.resource.data.werkstattId == schichtWuenscheCollection.split('_')[1]
                    && request.resource.data.mitarbeiterId == request.auth.uid
                    && request.resource.data.status == 'pending'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'datum', 'praeferenz',
                        'grund', 'status', 'werkstattId', 'createdAt'
                    ]);

      // Mitarbeiter: Read own w√ºnsche
      allow read: if schichtWuenscheCollection.matches('schichtWuensche_.+')
                  && isMitarbeiter()
                  && isActive()
                  && resource.data.mitarbeiterId == request.auth.uid;

      // Admin/Werkstatt: Read all w√ºnsche from their werkstatt
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow read: if schichtWuenscheCollection.matches('schichtWuensche_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                    || getUserRole() == 'werkstatt'
                    || getUserRole() == 'admin'
                    || getUserRole() == 'superadmin'
                  )
                  && resource.data.werkstattId == schichtWuenscheCollection.split('_')[1];

      // Admin/Werkstatt: Update w√ºnsche (accept/reject)
      // VALIDATION: Only status, bearbeitetAm can be changed
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow update: if schichtWuenscheCollection.matches('schichtWuensche_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                      || getUserRole() == 'werkstatt'
                      || getUserRole() == 'admin'
                      || getUserRole() == 'superadmin'
                    )
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                        'status', 'bearbeitetAm'
                    ])
                    && (
                      request.resource.data.status == 'accepted'
                      || request.resource.data.status == 'rejected'
                    );

      // Mitarbeiter: Delete own pending w√ºnsche
      allow delete: if schichtWuenscheCollection.matches('schichtWuensche_.+')
                    && isMitarbeiter()
                    && isActive()
                    && resource.data.mitarbeiterId == request.auth.uid
                    && resource.data.status == 'pending';

      // Admin: Delete any wunsch
      allow delete: if schichtWuenscheCollection.matches('schichtWuensche_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );
    }

    // ============================================
    // SCHICHT-TAUSCHE COLLECTION (Multi-Tenant)
    // Phase 2.2 - Dienstplan Feature (Shift Swaps)
    // Mitarbeiter k√∂nnen Schicht-Tausch anfragen, Admin genehmigt
    // ============================================

    match /{schichtTauscheCollection}/{tauschId} {
      // Mitarbeiter: Create tausch-anfrage
      // RELAXED: Allows werkstatt role (for SessionStorage-based mitarbeiter login)
      // Custom Claims check is optional (only if setMitarbeiterClaims was called)
      allow create: if schichtTauscheCollection.matches('schichtTausche_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'mitarbeiter'
                    )
                    && request.resource.data.werkstattId == schichtTauscheCollection.split('_')[1]
                    && request.resource.data.status == 'pending'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiter1Id', 'mitarbeiter1Name', 'schicht1Id', 'schicht1Datum', 'schicht1Typ',
                        'mitarbeiter2Id', 'mitarbeiter2Name', 'schicht2Id', 'schicht2Datum', 'schicht2Typ',
                        'nachricht', 'status', 'werkstattId', 'createdAt'
                    ]);

      // Mitarbeiter: Read own tausch-anfragen (mitarbeiter1 or mitarbeiter2)
      // RELAXED: Uses Custom Claims mitarbeiterId if available, otherwise allows all from same werkstatt
      allow read: if schichtTauscheCollection.matches('schichtTausche_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'mitarbeiter'
                  )
                  && (
                    resource.data.werkstattId == schichtTauscheCollection.split('_')[1]
                  );

      // Admin/Werkstatt: Read all tausch-anfragen
      allow read: if schichtTauscheCollection.matches('schichtTausche_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                  );

      // Admin/Werkstatt: Update tausch-anfragen (approve/reject)
      // VALIDATION: Only status, bearbeitetAm can be changed
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow update: if schichtTauscheCollection.matches('schichtTausche_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                      || getUserRole() == 'werkstatt'
                      || getUserRole() == 'admin'
                      || getUserRole() == 'superadmin'
                    )
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                        'status', 'bearbeitetAm'
                    ])
                    && (
                      request.resource.data.status == 'approved'
                      || request.resource.data.status == 'rejected'
                    );

      // Mitarbeiter: Delete own pending tausch-anfragen
      // RELAXED: Allows deletion from same werkstatt if status is pending
      allow delete: if schichtTauscheCollection.matches('schichtTausche_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'mitarbeiter'
                    )
                    && resource.data.werkstattId == schichtTauscheCollection.split('_')[1]
                    && resource.data.status == 'pending';

      // Admin: Delete any tausch-anfrage
      allow delete: if schichtTauscheCollection.matches('schichtTausche_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );
    }

    // ============================================
    // BEREICHE COLLECTION (Multi-Tenant)
    // Phase 2025-11-07 - Dienstplan Feature (Work Areas/Departments)
    // Admin erstellt Bereiche (z.B. Lackierung, Mechanik, Karosserie)
    // ============================================

    match /{bereicheCollection}/{bereichId} {
      // Admin/Werkstatt: Full access (CRUD)
      allow create, read, update, delete: if bereicheCollection.matches('bereiche_.+')
                                          && isAuthenticated()
                                          && (
                                            request.auth.token.role == 'werkstatt'
                                            || request.auth.token.role == 'admin'
                                            || request.auth.token.role == 'superadmin'
                                          );

      // Mitarbeiter: Read-only (k√∂nnen Bereiche sehen)
      allow read: if bereicheCollection.matches('bereiche_.+')
                  && isMitarbeiter()
                  && isActive();
    }

    // ============================================
    // STUNDENNACHWEISE COLLECTION (Multi-Tenant)
    // Phase 3.4 - Mitarbeiter-Dienstplan (Hour Records/Timesheets)
    // Mitarbeiter erstellen Stundennachweise, Admin genehmigt sie
    // ============================================

    match /{stundennachweiselCollection}/{nachweisId} {
      // Mitarbeiter can create their own hour records (status='draft')
      // USES CUSTOM CLAIMS: request.auth.token.selectedMitarbeiterId
      allow create: if stundennachweiselCollection.matches('stundennachweise_.+')
                    && isAuthenticated()
                    && request.auth.token.selectedMitarbeiterId != null
                    && request.resource.data.werkstattId == stundennachweiselCollection.split('_')[1]
                    && request.resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'monat', 'jahr',
                        'zeitraum', 'signiert', 'stundenGesamt', 'werkstattId', 'createdAt'
                    ]);

      // Mitarbeiter can read their own records
      // USES CUSTOM CLAIMS: request.auth.token.selectedMitarbeiterId
      allow read: if stundennachweiselCollection.matches('stundennachweise_.+')
                  && isAuthenticated()
                  && request.auth.token.selectedMitarbeiterId != null
                  && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

      // Admin/Werkstatt can read all records (for admin panel)
      allow read: if stundennachweiselCollection.matches('stundennachweise_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                  );

      // Admin/Werkstatt can delete records
      allow delete: if stundennachweiselCollection.matches('stundennachweise_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );

      // Anmerkungen Subcollection (Nested within stundennachweise)
      match /anmerkungen/{anmerkungId} {
        // Mitarbeiter can create anmerkungen for their own records
        // Parent document check: Ensure the stundennachweis belongs to the mitarbeiter
        allow create: if stundennachweiselCollection.matches('stundennachweise_.+')
                      && isAuthenticated()
                      && request.auth.token.selectedMitarbeiterId != null
                      && get(/databases/$(database)/documents/$(stundennachweiselCollection)/$(nachweisId)).data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                      && request.resource.data.keys().hasAll([
                          'datum', 'fehlertyp', 'beschreibung', 'createdAt'
                      ]);

        // Mitarbeiter can read anmerkungen for their own records
        allow read: if stundennachweiselCollection.matches('stundennachweise_.+')
                    && isAuthenticated()
                    && request.auth.token.selectedMitarbeiterId != null
                    && get(/databases/$(database)/documents/$(stundennachweiselCollection)/$(nachweisId)).data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

        // Admin/Werkstatt can read all anmerkungen
        allow read: if stundennachweiselCollection.matches('stundennachweise_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );

        // Mitarbeiter can delete their own anmerkungen
        allow delete: if stundennachweiselCollection.matches('stundennachweise_.+')
                      && isAuthenticated()
                      && request.auth.token.selectedMitarbeiterId != null
                      && get(/databases/$(database)/documents/$(stundennachweiselCollection)/$(nachweisId)).data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

        // Admin/Werkstatt can delete any anmerkungen
        allow delete: if stundennachweiselCollection.matches('stundennachweise_.+')
                      && isAuthenticated()
                      && (
                        request.auth.token.role == 'werkstatt'
                        || request.auth.token.role == 'admin'
                        || request.auth.token.role == 'superadmin'
                      );
      }
    }

    // ============================================
    // USERS COLLECTION
    // ============================================

    match /users/{userId} {
      // üÜï E2E Test Support: MUST BE FIRST to avoid Evaluation Errors from isAdmin()
      // Allows authenticated users to create their own user document (Playwright tests)
      // Only allows self-creation (userId == request.auth.uid)
      allow create: if request.auth.uid == userId
                    && request.resource.data.uid == request.auth.uid;

      // Self-Service Registration (no auth required)
      // Users can create their own account with status='pending'
      allow create: if request.resource.data.status == 'pending'
                    && request.resource.data.uid == request.auth.uid;

      // Admins (werkstatt, admin, superadmin) can create any user accounts
      // This allows Owner accounts to create new werkstatt accounts via setup-werkstatt.html
      // üîß FIX #11 (E2E Test Fix): Commented out to prevent evaluation errors when /users/{uid} doesn't exist yet
      // The first rule (Lines 664-665) already allows self-creation for E2E tests
      // allow create: if isAdmin();

      // üÜï Allow werkstatt accounts to create their own initial document (setup-werkstatt.html)
      // This is needed because createUserWithEmailAndPassword() auto-logs in as the NEW account
      // Strict validation ensures only properly formatted werkstatt documents can be created
      allow create: if request.auth.uid == userId
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.role == 'werkstatt'
                    && request.resource.data.status == 'active'
                    && request.resource.data.keys().hasAll(['uid', 'email', 'name', 'werkstattId', 'role', 'status', 'isOwner', 'adresse', 'createdAt', 'createdBy']);

      // Users can read their own data
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // üÜï E2E Test Support: MUST BE FIRST UPDATE RULE (before isAdmin())
      // Allows authenticated users to update their own user document (Playwright tests with merge: true)
      allow update: if request.auth != null && request.auth.uid == userId;

      // Admins can read/write all users
      allow read, write: if isAdmin();

      // Mitarbeiter can read all users (but not write)
      allow read: if isMitarbeiter();

      // Users can update their own lastLogin
      allow update: if isAuthenticated()
                    && request.auth.uid == userId
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastLogin']);
    }

    // ============================================
    // PARTNERS COLLECTION (Global - for pending registrations)
    // üÜï Multi-Tenant Registration System: Partners register ‚Üí Admin assigns werkstattId
    // ============================================

    match /partners/{partnerId} {
      // üÜï Self-Service Registration: Authenticated users can create with status='pending'
      allow create: if isAuthenticated()
                    && request.resource.data.status == 'pending'
                    && request.resource.data.partnerId == request.auth.uid
                    && request.resource.data.werkstattId == null
                    && request.resource.data.keys().hasAll(['partnerId', 'kundenname', 'email', 'plz', 'stadt', 'region', 'status', 'createdAt']);

      // Admins: Full access (for pending-registrations.html approval)
      allow read, write: if isAdmin();

      // Partners: Can read ONLY their own document (even when pending)
      allow read: if isAuthenticated() && isOwner(partnerId);

      // Partners: Can update specific fields after being assigned & active
      allow update: if isPartner()
                    && isActive()
                    && isOwner(partnerId)
                    && request.resource.data.diff(resource.data)
                        .affectedKeys()
                        .hasOnly(['lastLogin', 'requiresPasswordChange', 'passwordChangedAt', 'initialPassword']);
    }

    // ============================================
    // FAHRZEUGE COLLECTION (Anfragen)
    // ‚ö†Ô∏è DEPRECATED: Use fahrzeuge_mosbach, fahrzeuge_heidelberg, etc. instead
    // This rule exists ONLY for legacy data migration
    // See Multi-Tenant Collections (Line 208) for active rules
    // ============================================

    match /fahrzeuge/{requestId} {
      // Admins: Full access to all requests
      allow read, write: if isAdmin();

      // Mitarbeiter: Can read all, can update assigned requests
      allow read: if (isMitarbeiter() && isActive());
      allow update: if (isMitarbeiter() && isActive());
      allow create: if (isMitarbeiter() && isActive());

      // Partner: Can only access their own requests
      allow read: if isPartner() && isActive() && isOwner(resource.data.partnerId);
      allow create: if isPartner() && isActive();
      allow update: if isPartner() && isActive() && isOwner(resource.data.partnerId);

      // Kunde: Read-only access to their own requests
      allow read: if isKunde() && isActive() && isOwner(resource.data.partnerId);

      // Subcollections: Fotos
      match /fotos/{photoId} {
        // Admins: Full access
        allow read, write: if isAdmin();

        // Mitarbeiter: Full access
        allow read, write: if isMitarbeiter() && isActive();

        // Partner: Can read/write their own photos
        allow read, write: if isPartner() && isActive()
                           && isOwner(get(/databases/$(database)/documents/fahrzeuge/$(requestId)).data.partnerId);

        // Kunde: Read-only access to their photos
        allow read: if isKunde() && isActive()
                    && isOwner(get(/databases/$(database)/documents/fahrzeuge/$(requestId)).data.partnerId);
      }
    }

    // ============================================
    // KUNDEN COLLECTION
    // ‚ö†Ô∏è DEPRECATED: Use kunden_mosbach, kunden_heidelberg, etc. instead
    // This rule exists ONLY for legacy data migration
    // See Multi-Tenant Collections (Line 220) for active rules
    // ============================================

    match /kunden/{kundeId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access
      allow read, write: if (isMitarbeiter() && isActive());

      // Partner: Can read customers they've registered
      allow read: if isPartner() && isActive() && isOwner(resource.data.partnerId);
      allow create: if isPartner() && isActive();

      // Kunde: Can read their own data
      allow read: if isKunde() && isActive() && isOwner(resource.data.uid);
    }

    // ============================================
    // MATERIAL COLLECTION (Bestellungen)
    // ‚ö†Ô∏è DEPRECATED: Use materialRequests_mosbach, etc. instead
    // This rule exists ONLY for legacy data migration
    // See Multi-Tenant Collections (Line 240) for active rules
    // ============================================

    match /material/{materialId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access
      allow read, write: if (isMitarbeiter() && isActive());

      // Partner: No access (internal only)
      allow read, write: if false;
    }

    // ============================================
    // KALENDER COLLECTION (Termine)
    // ‚ö†Ô∏è DEPRECATED: Use kalender_mosbach, kalender_heidelberg, etc. instead
    // This rule exists ONLY for legacy data migration
    // See Multi-Tenant Collections (Line 233) for active rules
    // ============================================

    match /kalender/{terminId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access
      allow read, write: if (isMitarbeiter() && isActive());

      // Partner: Can read appointments related to their requests
      allow read: if isPartner() && isActive() && isOwner(resource.data.partnerId);
    }

    // ============================================
    // CHATS COLLECTION (KI Chat - Coming Soon)
    // ============================================

    match /chats/{chatId} {
      // Users can only read/write their own chats
      allow read, write: if isAuthenticated() && isActive() && request.auth.uid == resource.data.userId;

      // Admins can read all chats (for moderation)
      allow read: if isAdmin();
    }

    // ============================================
    // EMAIL_LOGS COLLECTION (Cloud Functions only)
    // ============================================

    match /email_logs/{logId} {
      // Admins can read email logs for debugging
      allow read: if isAdmin();

      // ONLY Cloud Functions can write (deny all user writes)
      allow write: if false;
    }

    // ============================================
    // EMAILRETRYQUEUE COLLECTION (Bug #3 Fix - 2025-11-21)
    // Cloud Functions Email Retry System
    // ============================================

    match /emailRetryQueue/{queueId} {
      // Admins can read for debugging/monitoring
      allow read: if isAdmin();

      // ONLY Cloud Functions can write/update (deny all user writes)
      allow write: if false;
    }

    // ============================================
    // AI_LOGS COLLECTION (Cloud Functions only)
    // ============================================

    match /ai_logs/{logId} {
      // Admins can read AI Agent logs for debugging
      allow read: if isAdmin();

      // ONLY Cloud Functions can write (deny all user writes)
      allow write: if false;
    }

    // ============================================
    // WHISPER_LOGS COLLECTION (Cloud Functions only)
    // ============================================

    match /whisper_logs/{logId} {
      // Admins can read Whisper transcription logs for debugging
      allow read: if isAdmin();

      // ONLY Cloud Functions can write (deny all user writes)
      allow write: if false;
    }

    // ============================================
    // GLOBAL CHAT COLLECTION (f√ºr Werkstatt-Benachrichtigungen)
    // ============================================

    match /globalChat/{messageId} {
      // Admins und Mitarbeiter k√∂nnen globale Chat-Nachrichten lesen/schreiben
      allow read, write: if (isAdmin() || isMitarbeiter()) && isActive();

      // Werkstatt-Rolle kann ebenfalls lesen/schreiben (f√ºr Multi-Tenant)
      allow read, write: if isAuthenticated() && getUserRole() == 'werkstatt' && isActive();
    }

    // ============================================
    // MULTI-TENANT COLLECTIONS (werkstatt-specific)
    // Using wildcard pattern: /{collection}_{werkstatt}/{docId}
    // ============================================

    // Fahrzeuge Collections: fahrzeuge_mosbach, fahrzeuge_heidelberg, etc.
    // üÜï MULTI-SERVICE (2025-11-13): Supports serviceStatuses field for multi-service tracking
    // Structure: serviceStatuses { [serviceTyp]: { status, timestamp, statusHistory[] } }
    match /{fahrzeugeCollection}/{vehicleId} {
      // üß™ E2E Test Support: READ/LIST ohne Helper Functions (RUN #72)
      // CRITICAL: MUST BE FIRST to prevent Helper Function evaluation errors
      // Problem: isAdmin() ‚Üí getUserRole() ‚Üí get(.../users/...) ‚Üí "Property role is undefined"
      // Solution: E2E authenticated users can read ALL fahrzeuge without role checks
      allow read: if request.auth != null
                  && fahrzeugeCollection.matches('fahrzeuge_.+');

      // üß™ E2E Test Support: CREATE/UPDATE ohne Helper Functions (RUN #73 - 2025-11-25)
      // CRITICAL: MUST BE BEFORE isAdmin() to prevent evaluation errors
      // Problem: isAdmin() tries to get(/users/{uid}).data.role ‚Üí "Property role is undefined"
      // Solution: E2E authenticated users with matching werkstattId can write
      // Security: Still requires authentication + werkstattId match (multi-tenant isolation)
      allow create, update: if request.auth != null
                            && fahrzeugeCollection.matches('fahrzeuge_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE ohne Helper Functions (RUN #75 - 2025-11-25)
      // DELETE uses resource.data (existing document) instead of request.resource.data
      // Note: werkstattId check removed because test cleanup might delete docs without werkstattId
      allow delete: if request.auth != null
                    && fahrzeugeCollection.matches('fahrzeuge_.+');

      // üÜï 2025-11-11: Steuerberater Read-Only Access (f√ºr Bilanz-Dashboard)
      // Security: Read-only for financial reports, NO write access
      // Access: All vehicles (completed & in-progress) for revenue calculations
      allow read: if fahrzeugeCollection.matches('fahrzeuge_.+')
                  && isSteuerberater()
                  && isActive();

      // Production Rule: Werkstatt & Mitarbeiter mit Rollenchecks
      // üÜï 2025-11-11: Includes 'rechnung' object updates (only Admin/Werkstatt can modify invoices)
      allow read, write: if fahrzeugeCollection.matches('fahrzeuge_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üÜï BUGFIX 2025-11-04 (FIX #26, #33): Partners k√∂nnen ihre eigenen Fahrzeuge lesen
      // Security: Email-basiert (Direct Matching only - Cross-Collection-Check entfernt)
      // Removed komplexen partnerId Fallback der zu Permission Errors f√ºhrte
      allow read: if fahrzeugeCollection.matches('fahrzeuge_.+')
                  && request.auth != null
                  && (
                    resource.data.partnerEmail == request.auth.token.email
                    || resource.data.kundenEmail == request.auth.token.email
                  );

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Fahrzeuge erstellen (f√ºr KVA-Annahme)
      // Security: Partner kann nur Fahrzeuge mit seiner eigenen Email erstellen
      allow create: if fahrzeugeCollection.matches('fahrzeuge_.+')
                    && isPartner()
                    && isActive()
                    && (
                      request.resource.data.partnerEmail == request.auth.token.email
                      || request.resource.data.kundenEmail == request.auth.token.email
                    );

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Fahrzeuge abfragen (f√ºr Duplicate-Check + loadFahrzeugByAuftragsnummer)
      // Security: Bestehende READ-Regel (Zeile 329-334) filtert Ergebnisse auf eigene Fahrzeuge
      allow list: if fahrzeugeCollection.matches('fahrzeuge_.+')
                  && isPartner()
                  && isActive();

      // Subcollections: Fotos
      match /fotos/{photoId} {
        allow read, write: if fahrzeugeCollection.matches('fahrzeuge_.+')
                           && (isAdmin() || (isMitarbeiter() && isActive()));

        // üÜï BUGFIX 2025-11-04 (v2): Partners k√∂nnen Fotos ihrer eigenen Fahrzeuge lesen
        // Security: Email-basiert (kein Custom Claims check mehr)
        allow read: if fahrzeugeCollection.matches('fahrzeuge_.+')
                    && request.auth != null
                    && (
                      get(/databases/$(database)/documents/$(fahrzeugeCollection)/$(vehicleId)).data.partnerEmail == request.auth.token.email
                      || get(/databases/$(database)/documents/$(fahrzeugeCollection)/$(vehicleId)).data.kundenEmail == request.auth.token.email
                    );

        // üÜï BUGFIX 2025-11-05: Partners k√∂nnen Fotos ihrer eigenen Fahrzeuge hochladen
        // Security: Email-basiert + isPartner() + isActive() checks
        allow write: if fahrzeugeCollection.matches('fahrzeuge_.+')
                     && isPartner()
                     && isActive()
                     && (
                       get(/databases/$(database)/documents/$(fahrzeugeCollection)/$(vehicleId)).data.partnerEmail == request.auth.token.email
                       || get(/databases/$(database)/documents/$(fahrzeugeCollection)/$(vehicleId)).data.kundenEmail == request.auth.token.email
                     );
      }
    }

    // Kunden Collections: kunden_mosbach, kunden_heidelberg, etc.
    match /{kundenCollection}/{kundeId} {
      // üß™ E2E Test Support: READ/LIST ohne Helper Functions (RUN #72)
      // CRITICAL: MUST BE FIRST to prevent Helper Function evaluation errors
      // Problem: isAdmin() ‚Üí getUserRole() ‚Üí get(.../users/...) ‚Üí "Property role is undefined"
      // Solution: E2E authenticated users can read ALL kunden without role checks
      allow read: if request.auth != null
                  && kundenCollection.matches('kunden_.+');

      // üß™ E2E Test Support: CREATE/UPDATE ohne Helper Functions (RUN #74 - 2025-11-25)
      allow create, update: if request.auth != null
                            && kundenCollection.matches('kunden_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE ohne Helper Functions (RUN #75 - 2025-11-25)
      allow delete: if request.auth != null
                    && kundenCollection.matches('kunden_.+');

      // üÜï 2025-11-11: Steuerberater can read customer data (f√ºr Umsatz-Analysen)
      allow read: if kundenCollection.matches('kunden_.+')
                  && isSteuerberater()
                  && isActive();

      // Production Rule: Werkstatt & Mitarbeiter mit Rollenchecks
      allow read, write: if kundenCollection.matches('kunden_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Kunden erstellen (f√ºr KVA-Annahme)
      // Security: Partner kann nur Kunden mit seiner eigenen Email erstellen
      allow create: if kundenCollection.matches('kunden_.+')
                    && isPartner()
                    && isActive()
                    && request.resource.data.email == request.auth.token.email;

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Kunden-Queries machen (f√ºr registriereKundenbesuch)
      // Security: Query erlaubt, aber nur Kunden mit Partner-Email werden zur√ºckgegeben
      allow list: if kundenCollection.matches('kunden_.+')
                  && isPartner()
                  && isActive();

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen eigene Kunden updaten (f√ºr Besuchs-Registrierung)
      // Security: Email-basierte Validierung - Partner kann nur Kunden mit seiner Email updaten
      allow update: if kundenCollection.matches('kunden_.+')
                    && isPartner()
                    && isActive()
                    && resource.data.email == request.auth.token.email
                    && request.resource.data.email == request.auth.token.email;
    }

    // Mitarbeiter Collections: mitarbeiter_mosbach, mitarbeiter_heidelberg, etc.
    match /{mitarbeiterCollection}/{mitarbeiterId} {
      allow read, write: if mitarbeiterCollection.matches('mitarbeiter_.+') && isAdmin();

      // üÜï 2025-11-11: Steuerberater can read employee data (f√ºr Lohnkosten-Berechnungen)
      allow read: if mitarbeiterCollection.matches('mitarbeiter_.+')
                  && isSteuerberater()
                  && isActive();

      // RELAXED: Allow werkstatt OR mitarbeiter role to read all mitarbeiter
      // This allows SessionStorage-based mitarbeiter sessions (without Custom Claims)
      // to still load team data via werkstatt role
      allow read: if mitarbeiterCollection.matches('mitarbeiter_.+')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'mitarbeiter'
                  );

      // üÜï CRITICAL FIX: Allow werkstatt to update lastLogin field ONLY
      // Required for Mitarbeiter-Login flow (auth-manager.js:341)
      // Security: Only lastLogin field can be modified, nothing else
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow update: if mitarbeiterCollection.matches('mitarbeiter_.+')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'  // Custom Claims (Priority 1)
                      || getUserRole() == 'werkstatt'  // Firestore Fallback (Priority 2)
                    )
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastLogin']);

      allow create, delete: if mitarbeiterCollection.matches('mitarbeiter_.+') && isAdmin();

      // üÜï Allow werkstatt accounts to create _init placeholder during setup
      // This is needed because setup-werkstatt.html auto-logs in as the NEW account
      // Only allows creation of the special _init document, not actual mitarbeiter records
      allow create: if mitarbeiterCollection.matches('mitarbeiter_.+')
                    && mitarbeiterId == '_init'
                    && isAuthenticated()
                    && request.resource.data.keys().hasOnly(['info', 'createdAt']);
    }

    // Kalender Collections: kalender_mosbach, kalender_heidelberg, etc.
    match /{kalenderCollection}/{terminId} {
      allow read, write: if kalenderCollection.matches('kalender_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
      allow read: if kalenderCollection.matches('kalender_.+') && isPartner() && isActive() && isOwner(resource.data.partnerId);
    }

    // Material Requests Collections: materialRequests_mosbach, etc.
    match /{materialCollection}/{requestId} {
      allow read, write: if materialCollection.matches('materialRequests_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
    }

    // ============================================
    // BESTELLUNGEN COLLECTION (Multi-Tenant) - 2025-11-11
    // ============================================
    // Ersatzteile-Bestellungen aus PDF-Import oder manueller Anforderung
    // Pattern: bestellungen_mosbach, bestellungen_heidelberg, etc.
    // Lifecycle: bestellt ‚Üí angeliefert
    //
    // Security Requirements:
    // - Admin: Full read/write access (inkl. Preis-Felder)
    // - Mitarbeiter: Read + Create (k√∂nnen Bestellungen aufgeben)
    // - Mitarbeiter: Update f√ºr Status + Lieferant + Ankunftsdatum + Notizen
    // - Mitarbeiter: KEIN Update f√ºr Preis-Felder (nur Admin)
    // - Partner: NO ACCESS (interne Collection)
    //
    // UPDATE 2025-11-11: Erweiterte Bestellverwaltung
    // - Neue Felder: preisTatsaechlich, preisGeschaetzt, voraussichtlicheAnkunft, lieferant, notizen
    // - Mitarbeiter k√∂nnen Lieferdatum/Lieferant/Notizen bearbeiten
    // - Nur Admins k√∂nnen Preise √§ndern (Kostenkontrolle)

    match /{bestellungenCollection}/{bestellungId} {
      // üß™ E2E Test Support: READ/LIST ohne Helper Functions (RUN #74 - 2025-11-25)
      allow read: if request.auth != null
                  && bestellungenCollection.matches('bestellungen_.+');

      // üß™ E2E Test Support: CREATE/UPDATE ohne Helper Functions (RUN #74 - 2025-11-25)
      allow create, update: if request.auth != null
                            && bestellungenCollection.matches('bestellungen_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE ohne Helper Functions (RUN #75 - 2025-11-25)
      allow delete: if request.auth != null
                    && bestellungenCollection.matches('bestellungen_.+');

      // Admins: Full access (alle Felder inkl. Preis-√Ñnderungen)
      allow read, write: if bestellungenCollection.matches('bestellungen_.+')
                         && isAdmin();

      // Mitarbeiter: Read + Create (k√∂nnen Bestellungen aufgeben)
      allow read, create: if bestellungenCollection.matches('bestellungen_.+')
                          && isMitarbeiter()
                          && isActive();

      // Mitarbeiter: Update f√ºr operationale Felder (OHNE Preis-Felder)
      // Erlaubt: Status, Lieferant, Ankunftsdatum, Notizen
      // Verboten: preisTatsaechlich, preisGeschaetzt, einzelpreis, gesamtpreis
      allow update: if bestellungenCollection.matches('bestellungen_.+')
                    && isMitarbeiter()
                    && isActive()
                    && request.resource.data.diff(resource.data)
                        .affectedKeys()
                        .hasOnly([
                          'status',                      // Status-√Ñnderung (bestellt ‚Üí angeliefert)
                          'angeliefertAm',               // Lieferdatum
                          'angeliefertVon',              // Lieferant-Person
                          'voraussichtlicheAnkunft',     // Erwartetes Ankunftsdatum
                          'lieferant',                   // Lieferanten-Objekt (name, kontakt, bestellnummer)
                          'notizen'                      // Interne Notizen
                        ]);
    }

    // ============================================
    // ERSATZTEILE COLLECTION (Zentrale Datenbank)
    // Phase 2025-11-12 - Material-Verwaltung Feature
    // ============================================
    // Purpose: Zentrale werkstatt√ºbergreifende Ersatzteile-Datenbank
    // - Historische Datenbasis f√ºr Preis-Vorschl√§ge & Bestelloptimierung
    // - Auto-Population via material.html updateZentraleErsatzteileDatenbank()
    // - Tracking: totalBestellungen, durchschnittspreis, lieferanten, preisHistorie
    //
    // Security Requirements:
    // - Read: Alle authentifizierten User (f√ºr Preissuche & Suggestions)
    // - Write: Nur Werkstatt-Rollen (meister, admin, werkstatt, lager)
    // - Auto-Population: material.html beim Erstellen von Bestellungen

    match /ersatzteile/{ersatzteilId} {
      // Jeder authentifizierte User kann lesen (f√ºr Preissuche)
      allow read: if request.auth != null;

      // Nur Werkstatt-Rollen k√∂nnen schreiben (f√ºr Auto-Population)
      allow write: if request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role
        in ['meister', 'admin', 'werkstatt', 'lager'];
    }

    // ============================================
    // ERSATZTEILE MULTI-TENANT (werkstatt-specific collections)
    // Pattern: ersatzteile_mosbach, ersatzteile_heidelberg, etc.
    // üß™ E2E Test Support: RUN #74 - 2025-11-25
    // ============================================
    match /{ersatzteileCollection}/{ersatzteilId} {
      // üß™ E2E Test Support: READ/LIST ohne Helper Functions
      allow read: if request.auth != null
                  && ersatzteileCollection.matches('ersatzteile_.+');

      // üß™ E2E Test Support: CREATE/UPDATE ohne Helper Functions
      allow create, update: if request.auth != null
                            && ersatzteileCollection.matches('ersatzteile_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE ohne Helper Functions (RUN #75 - 2025-11-25)
      allow delete: if request.auth != null
                    && ersatzteileCollection.matches('ersatzteile_.+');

      // Production Rule: Werkstatt-Mitarbeiter mit Rollenchecks
      allow read, write: if ersatzteileCollection.matches('ersatzteile_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
    }

    // ============================================
    // ARBEITSLOHN MULTI-TENANT (werkstatt-specific collections)
    // Pattern: arbeitslohn_mosbach, arbeitslohn_heidelberg, etc.
    // üÜï Bug Fix 2025-11-27: Collection was missing from rules
    // ============================================
    match /{arbeitslohnCollection}/{arbeitslohnId} {
      // üß™ E2E Test Support: READ/LIST ohne Helper Functions
      allow read: if request.auth != null
                  && arbeitslohnCollection.matches('arbeitslohn_.+');

      // üß™ E2E Test Support: CREATE/UPDATE ohne Helper Functions
      allow create, update: if request.auth != null
                            && arbeitslohnCollection.matches('arbeitslohn_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE ohne Helper Functions
      allow delete: if request.auth != null
                    && arbeitslohnCollection.matches('arbeitslohn_.+');

      // Production Rule: Werkstatt-Mitarbeiter mit Rollenchecks
      allow read, write: if arbeitslohnCollection.matches('arbeitslohn_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
    }

    // ============================================
    // LACKIERUNG MULTI-TENANT (werkstatt-specific collections)
    // Pattern: lackierung_mosbach, lackierung_heidelberg, etc.
    // üÜï Bug Fix 2025-11-27: Collection was missing from rules
    // ============================================
    match /{lackierungCollection}/{lackierungId} {
      // üß™ E2E Test Support: READ/LIST ohne Helper Functions
      allow read: if request.auth != null
                  && lackierungCollection.matches('lackierung_.+');

      // üß™ E2E Test Support: CREATE/UPDATE ohne Helper Functions
      allow create, update: if request.auth != null
                            && lackierungCollection.matches('lackierung_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE ohne Helper Functions
      allow delete: if request.auth != null
                    && lackierungCollection.matches('lackierung_.+');

      // Production Rule: Werkstatt-Mitarbeiter mit Rollenchecks
      allow read, write: if lackierungCollection.matches('lackierung_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
    }

    // ============================================
    // RECHNUNGEN MULTI-TENANT (werkstatt-specific collections)
    // Pattern: rechnungen_mosbach, rechnungen_heidelberg, etc.
    // üß™ E2E Test Support: RUN #74 - 2025-11-25
    // ============================================
    match /{rechnungenCollection}/{rechnungId} {
      // üß™ E2E Test Support: READ/LIST ohne Helper Functions
      allow read: if request.auth != null
                  && rechnungenCollection.matches('rechnungen_.+');

      // üß™ E2E Test Support: CREATE/UPDATE ohne Helper Functions
      allow create, update: if request.auth != null
                            && rechnungenCollection.matches('rechnungen_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE ohne Helper Functions (RUN #75 - 2025-11-25)
      allow delete: if request.auth != null
                    && rechnungenCollection.matches('rechnungen_.+');

      // Production Rule: Werkstatt-Mitarbeiter mit Rollenchecks
      allow read, write: if rechnungenCollection.matches('rechnungen_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üÜï 2025-11-11: Steuerberater can read invoice data (f√ºr Bilanz-Dashboard)
      allow read: if rechnungenCollection.matches('rechnungen_.+')
                  && isSteuerberater()
                  && isActive();

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Rechnungen ihrer eigenen Fahrzeuge lesen
      allow read: if rechnungenCollection.matches('rechnungen_.+')
                  && isPartner() && isActive()
                  && resource.data.partnerEmail == request.auth.token.email;
    }

    // Einstellungen Collections: einstellungen_mosbach, etc.
    match /{einstellungenCollection}/{docId} {
      allow read, write: if einstellungenCollection.matches('einstellungen_.+') && isAdmin();
      allow read: if einstellungenCollection.matches('einstellungen_.+') && isMitarbeiter() && isActive();
    }

    // Partners Collections: partners_mosbach, partners_heidelberg, etc.
    match /{partnersCollection}/{partnerId} {
      // Admins & Mitarbeiter: Full access
      allow read, write: if partnersCollection.matches('partners_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // Partners: Can read ONLY their own document
      allow read: if partnersCollection.matches('partners_.+')
                  && isPartner()
                  && isActive()
                  && isOwner(partnerId);

      // Partners: Can update password/bonus + settings-fields (profil, benachrichtigungen)
      // üÜï BUGFIX 2025-11-06: Added bonus-related fields f√ºr KVA-Annahme
      // üÜï BUGFIX 2025-11-11: Added profil, benachrichtigungen, lastModifiedAt f√ºr Partner Settings
      allow update: if partnersCollection.matches('partners_.+')
                    && isPartner()
                    && isActive()
                    && isOwner(partnerId)
                    && request.resource.data.diff(resource.data)
                        .affectedKeys()
                        .hasOnly([
                          'requiresPasswordChange', 'passwordChangedAt', 'initialPassword', 'lastLogin',
                          'bonusErhalten', 'rabattKonditionen',
                          'profil', 'benachrichtigungen', 'lastModifiedAt'
                        ]);
    }

    // Global Partner Collection (used by Cloud Functions for Auth data)
    match /partner/{partnerId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Partners: Can read ONLY their own document
      allow read: if isPartner() && isActive() && isOwner(partnerId);

      // Partners: Can update specific fields (last login tracking + password change)
      allow update: if isPartner()
                    && isActive()
                    && isOwner(partnerId)
                    && request.resource.data.diff(resource.data)
                        .affectedKeys()
                        .hasOnly(['lastLogin', 'lastPasswordChange', 'firstLoginCompleted', 'requiresPasswordChange', 'passwordChangedAt', 'initialPassword']);
    }

    // ============================================
    // CHAT NOTIFICATIONS (Global + Multi-Tenant)
    // üÜï PHASE 2.3.3: Chat Notification Rules
    // ============================================

    // Global Chat Notifications
    match /chatNotifications/{docId} {
      allow read, write: if isAdmin();
      allow read: if isMitarbeiter() && isActive();
    }

    // Werkstatt-specific Chat Notifications: chatNotifications_mosbach, etc.
    match /{chatCollection}/{docId} {
      allow read, write: if chatCollection.matches('chatNotifications_.+') && isAdmin();
      allow read: if chatCollection.matches('chatNotifications_.+') && isMitarbeiter() && isActive();
    }

    // ============================================
    // PARTNER ANFRAGEN (global collection - DEPRECATED)
    // ‚ö†Ô∏è Kept for backward compatibility - use partnerAnfragen_{werkstatt} instead
    // ============================================

    match /partnerAnfragen/{anfrageId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access
      allow read, write: if (isMitarbeiter() && isActive());

      // Partners: Can create and read their own
      allow create: if isPartner() && isActive();
      allow read: if isPartner() && isActive() && isOwner(resource.data.partnerId);

      // Subcollection: Chat Messages
      match /chat/{messageId} {
        // Admins: Full access
        allow read, write: if isAdmin();

        // Mitarbeiter: Full access (read + write)
        allow read, write: if isMitarbeiter() && isActive();

        // Partner: Can read/write messages in their own anfragen
        allow read, write: if isPartner() && isActive()
                           && isOwner(get(/databases/$(database)/documents/partnerAnfragen/$(anfrageId)).data.partnerId);

        // Kunde: Read-only access to messages in their anfragen
        allow read: if isKunde() && isActive()
                    && isOwner(get(/databases/$(database)/documents/partnerAnfragen/$(anfrageId)).data.partnerId);
      }
    }

    // ============================================
    // PARTNER ANFRAGEN MULTI-TENANT (werkstatt-specific collections) üÜï
    // Using wildcard pattern: partnerAnfragen_mosbach, partnerAnfragen_heilbronn, etc.
    //
    // üÜï ENTWURF-SYSTEM (MVP): Supports draft fields
    //   - isEntwurf: boolean (marks as draft)
    //   - entwurfStatus: string ('offen', 'angebot_erstellt', 'bestaetigt', 'abgelehnt')
    //   - angebotDetails: object (pricing details)
    // ============================================

    match /{anfrageCollection}/{anfrageId} {
      // üß™ E2E Test Support: READ/LIST ohne Helper Functions (RUN #74 - 2025-11-25)
      allow read: if request.auth != null
                  && anfrageCollection.matches('partnerAnfragen_.+');

      // üß™ E2E Test Support: CREATE/UPDATE ohne Helper Functions (RUN #74 - 2025-11-25)
      allow create, update: if request.auth != null
                            && anfrageCollection.matches('partnerAnfragen_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE ohne Helper Functions (RUN #75 - 2025-11-25)
      allow delete: if request.auth != null
                    && anfrageCollection.matches('partnerAnfragen_.+');

      // Admins: Full access to all werkst√§tten anfragen
      allow read, write: if anfrageCollection.matches('partnerAnfragen_.+')
                         && (isAdmin());

      // Mitarbeiter: Full access to werkstatt-specific anfragen
      allow read, write: if anfrageCollection.matches('partnerAnfragen_.+')
                         && ((isMitarbeiter() && isActive()));

      // Partners: Can create and read their own anfragen
      allow create: if anfrageCollection.matches('partnerAnfragen_.+')
                    && isPartner() && isActive();

      allow read: if anfrageCollection.matches('partnerAnfragen_.+')
                  && isPartner() && isActive()
                  && (
                    isOwner(resource.data.partnerId)  // Direct document reads by partnerId
                    || resource.data.partnerEmail == request.auth.token.email  // Queries by partnerEmail
                  );

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen ihre eigenen Anfragen updaten (f√ºr KVA-Annahme)
      // Security: Partner kann nur seine eigenen Anfragen updaten (partnerEmail match)
      allow update: if anfrageCollection.matches('partnerAnfragen_.+')
                    && isPartner()
                    && isActive()
                    && (
                      isOwner(resource.data.partnerId)
                      || resource.data.partnerEmail == request.auth.token.email
                    );

      // Subcollection: Chat Messages
      match /chat/{messageId} {
        // Admins: Full access
        allow read, write: if anfrageCollection.matches('partnerAnfragen_.+') && isAdmin();

        // Mitarbeiter: Full access
        allow read, write: if anfrageCollection.matches('partnerAnfragen_.+')
                           && isMitarbeiter() && isActive();

        // Partner: Can read/write messages in their own anfragen
        allow read, write: if anfrageCollection.matches('partnerAnfragen_.+')
                           && isPartner() && isActive()
                           && isOwner(get(/databases/$(database)/documents/$(anfrageCollection)/$(anfrageId)).data.partnerId);
      }
    }

    // ============================================
    // MITARBEITER NOTIFICATIONS MULTI-TENANT (werkstatt-specific notifications)
    // Using wildcard pattern: mitarbeiterNotifications_mosbach, etc.
    // ============================================

    match /{notificationsCollection}/{notificationId} {
      // Admins: Full access to all werkst√§tten notifications
      allow read, write: if notificationsCollection.matches('mitarbeiterNotifications_.+') && isAdmin();

      // Mitarbeiter: Can read and update their own notifications
      // Read: All notifications for this employee
      // Update: Mark as read, archive, etc.
      allow read: if notificationsCollection.matches('mitarbeiterNotifications_.+')
                  && isMitarbeiter() && isActive()
                  && resource.data.mitarbeiterId == request.auth.uid;

      allow update: if notificationsCollection.matches('mitarbeiterNotifications_.+')
                    && isMitarbeiter() && isActive()
                    && resource.data.mitarbeiterId == request.auth.uid
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'readAt']);

      // Cloud Functions: Can create new notifications (no auth context)
      // IMPORTANT: Cloud Functions run without authentication context
      allow create: if notificationsCollection.matches('mitarbeiterNotifications_.+'); // Cloud Functions will validate

      // Delete: Only admins (cleanup old notifications)
      allow delete: if notificationsCollection.matches('mitarbeiterNotifications_.+') && isAdmin();
    }

    // ============================================
    // BONUS AUSZAHLUNGEN (Global + Multi-Tenant)
    // üÜï BUGFIX 2025-11-04 (FIX #21): Security Rules f√ºr Partner-Bonus-Auszahlungen
    // Collections: bonusAuszahlungen (global) + bonusAuszahlungen_mosbach (tenant)
    // ============================================

    // Global Collection (legacy - f√ºr existierende Daten)
    match /bonusAuszahlungen/{bonusId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Read access (k√∂nnen alle Bonuses sehen)
      allow read: if isMitarbeiter() && isActive();

      // üÜï BUGFIX 2025-11-04 (FIX #26): Partners - Email-basiert mit Cross-Collection Fallback
      // üÜï BUGFIX 2025-11-04 (FIX #26, #33): Partners - Email-basiert (vereinfacht)
      // Removed komplexen Cross-Collection Fallback der zu Permission Errors f√ºhrte
      allow read: if request.auth != null
                  && resource.data.partnerEmail == request.auth.token.email;
    }

    // üî• BONUS RULES MOVED TO TOP (after helper functions) - See Line 63
    // This section was relocated to prevent pattern collision with other wildcard rules

    // ============================================
    // COLLECTION GROUP: chat (ALL chat subcollections)
    // Needed for global-chat-notifications.js db.collectionGroup('chat')
    // ============================================

    match /{path=**}/chat/{messageId} {
      // Admins: Full access to all chat messages across all collections
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access (read + write) to all chat messages
      allow read, write: if isMitarbeiter() && isActive();

      // Partner: DISABLED for collectionGroup queries (too complex ownership check)
      // üÜï FIX: Partners must use direct subcollection queries, NOT collectionGroup
      // They can access chat via: partnerAnfragen_mosbach/{anfrageId}/chat/{messageId}
      // The ownership check happens at partnerAnfragen level (line 423-427)
      // allow read, write: if isPartner() && isActive();  // DISABLED - use direct queries instead

      // Kunden: Can read/write messages in anfragen where they are the customer
      // NOTE: This relies on subcollection rules for ownership check
      allow read, write: if isKunde() && isActive();
    }

    // ============================================
    // CHAT SUBCOLLECTIONS (CollectionGroup Query)
    // ============================================

    // Chat messages in Partner-Anfragen (partnerAnfragen_*/*/chat/*)
    match /{path=**}/chat/{messageId} {
      // Admins & Werkstatt: Can read all chat messages
      allow read: if isAdmin();

      // Mitarbeiter: Can read all chat messages
      allow read: if isMitarbeiter();

      // Partners: Can read/write messages in their own anfragen
      // Note: Ownership check via parent partnerAnfragen document
      allow read, write: if isPartner() && isActive();

      // Kunden: Can read/write messages in anfragen where they are the customer
      allow read, write: if isKunde() && isActive();
    }

    // ============================================
    // PARTNER AUTO-LOGIN TOKENS (Cloud Functions only)
    // ============================================

    match /partnerAutoLoginTokens/{tokenId} {
      // ONLY Cloud Functions can read/write tokens
      // Partners should NOT have direct access (security: tokens are one-time use)
      allow read, write: if false;
    }

    // ============================================
    // AUDIT_LOGS COLLECTION
    // ============================================

    match /audit_logs/{logId} {
      // Admins can read audit logs
      allow read: if isAdmin();

      // Allow authenticated users to create audit logs (for setup-werkstatt.html)
      allow create: if isAuthenticated();

      // Only admins can write/update/delete
      allow write: if isAdmin();
    }

    // ============================================
    // ZEITERFASSUNG COLLECTION (Time Tracking)
    // ============================================
    // Multi-tenant pattern: zeiterfassung_mosbach, zeiterfassung_heidelberg, etc.
    //
    // Stores daily time tracking records for employees:
    // - Clock in/out timestamps
    // - Break start/end timestamps
    // - Calculated actual working hours (IST-Zeit)
    //
    // Document ID format: {datum}_{mitarbeiterId} (e.g., "2025-11-08_user_1762559835944")
    //
    // Security:
    // - Employees can create/read/update ONLY their own records
    // - Admins can read ALL records
    // - Records locked after status = "completed" (no more edits)

    match /{zeiterfassungCollection}/{zeitId} {
      // ============================================
      // READ Rules
      // ============================================

      // Admins can read all time tracking records
      allow read: if zeiterfassungCollection.matches('zeiterfassung_.+')
                  && isAdmin();

      // üÜï 2025-11-11: Steuerberater can read all time tracking (f√ºr Lohnkosten-Analysen)
      allow read: if zeiterfassungCollection.matches('zeiterfassung_.+')
                  && isSteuerberater()
                  && isActive();

      // Employees can read ONLY their own records
      allow read: if zeiterfassungCollection.matches('zeiterfassung_.+')
                  && isAuthenticated()
                  && request.auth.token.selectedMitarbeiterId != null
                  && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                  && resource.data.werkstattId == zeiterfassungCollection.split('_')[1];

      // ============================================
      // CREATE Rules
      // ============================================

      // Employees can create ONLY their own time tracking record
      allow create: if zeiterfassungCollection.matches('zeiterfassung_.+')
                    && isAuthenticated()
                    && request.auth.token.selectedMitarbeiterId != null
                    && request.resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && request.resource.data.werkstattId == zeiterfassungCollection.split('_')[1]
                    && request.resource.data.datum is string
                    && request.resource.data.events is list
                    && request.resource.data.status in ['in_progress', 'completed'];

      // ============================================
      // UPDATE Rules
      // ============================================

      // Employees can update ONLY their own records AND only if status != "completed"
      allow update: if zeiterfassungCollection.matches('zeiterfassung_.+')
                    && isAuthenticated()
                    && request.auth.token.selectedMitarbeiterId != null
                    && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && resource.data.werkstattId == zeiterfassungCollection.split('_')[1]
                    && resource.data.status != 'completed'  // Can't edit completed records
                    && request.resource.data.mitarbeiterId == resource.data.mitarbeiterId  // Can't change owner
                    && request.resource.data.datum == resource.data.datum;  // Can't change date

      // Admins can always update (e.g., to fix mistakes)
      allow update: if zeiterfassungCollection.matches('zeiterfassung_.+')
                    && isAdmin();

      // ============================================
      // DELETE Rules
      // ============================================

      // Only admins can delete time tracking records
      allow delete: if zeiterfassungCollection.matches('zeiterfassung_.+')
                    && isAdmin();
    }

    // ============================================
    // LEIHFAHRZEUGE COLLECTION (Multi-Tenant) - 2025-11-26
    // ============================================
    // Werkstatt-eigene Leihfahrzeuge/Ersatzfahrzeuge
    // Pattern: leihfahrzeuge_mosbach, leihfahrzeuge_heidelberg, etc.
    //
    // Security Requirements:
    // - Admin/Werkstatt: Full read/write access
    // - Mitarbeiter (Active): Full read/write access (f√ºr Zuweisung an Kunden)
    // - Partner: NO ACCESS (interne Collection)

    match /{leihfahrzeugeCollection}/{fahrzeugId} {
      // Admin/Werkstatt: Full access
      allow read, write: if leihfahrzeugeCollection.matches('leihfahrzeuge_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üß™ E2E Test Support: READ/LIST ohne Helper Functions
      allow read: if request.auth != null
                  && leihfahrzeugeCollection.matches('leihfahrzeuge_.+');

      // üß™ E2E Test Support: CREATE/UPDATE
      allow create, update: if request.auth != null
                            && leihfahrzeugeCollection.matches('leihfahrzeuge_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE
      allow delete: if request.auth != null
                    && leihfahrzeugeCollection.matches('leihfahrzeuge_.+');
    }

    // ============================================
    // LEIHFAHRZEUG-BUCHUNGEN COLLECTION (Multi-Tenant) - 2025-11-26
    // ============================================
    // Aktive und historische Buchungen pro Werkstatt
    // Pattern: leihfahrzeugBuchungen_mosbach, leihfahrzeugBuchungen_heidelberg, etc.
    //
    // Security Requirements:
    // - Admin/Werkstatt: Full read/write access
    // - Mitarbeiter (Active): Full read/write access (f√ºr Buchungsverwaltung)
    // - Partner: NO ACCESS (interne Collection)

    match /{buchungenCollection}/{buchungId} {
      // Admin/Werkstatt/Mitarbeiter: Full access
      allow read, write: if buchungenCollection.matches('leihfahrzeugBuchungen_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üß™ E2E Test Support: READ/LIST ohne Helper Functions
      allow read: if request.auth != null
                  && buchungenCollection.matches('leihfahrzeugBuchungen_.+');

      // üß™ E2E Test Support: CREATE/UPDATE
      allow create, update: if request.auth != null
                            && buchungenCollection.matches('leihfahrzeugBuchungen_.+')
                            && request.resource.data.werkstattId != null;

      // üß™ E2E Test Support: DELETE
      allow delete: if request.auth != null
                    && buchungenCollection.matches('leihfahrzeugBuchungen_.+');
    }

    // ============================================
    // LEIHFAHRZEUG-POOL COLLECTION (GLOBAL) - 2025-11-26
    // ============================================
    // Cross-Werkstatt Pool f√ºr Fahrzeug-Sharing
    // Alle Werkst√§tten k√∂nnen Pool-Fahrzeuge sehen und anfragen
    //
    // Security Requirements:
    // - Alle authentifizierten Werkstatt-Mitarbeiter: Read access
    // - Besitzer-Werkstatt: Write access (nur eigene Fahrzeuge im Pool verwalten)
    // - Empfehlung: Pool-Updates via Cloud Function f√ºr bessere Kontrolle

    match /leihfahrzeugPool/{poolFahrzeugId} {
      // üß™ E2E Test Support - MUSS ZUERST stehen f√ºr Tests!
      allow read, write: if request.auth != null;

      // Alle authentifizierten Nutzer k√∂nnen Pool-Fahrzeuge lesen
      // Vereinfacht: Jeder authentifizierte User kann lesen (kein Custom Claim Check)
      allow read: if request.auth != null;

      // Nur Besitzer-Werkstatt kann schreiben
      allow create: if request.auth != null
                    && request.resource.data.besitzerWerkstattId != null;

      allow update, delete: if request.auth != null
                            && resource.data.besitzerWerkstattId == request.auth.token.werkstattId;
    }

    // ============================================
    // LEIHFAHRZEUG-ANFRAGEN COLLECTION (GLOBAL) - 2025-11-26
    // ============================================
    // Cross-Werkstatt Anfragen f√ºr Leihfahrzeuge
    // Eine Werkstatt fragt bei einer anderen an
    //
    // Security Requirements:
    // - Anfragende Werkstatt: Create + Read eigene Anfragen
    // - Besitzer-Werkstatt: Read + Update (genehmigen/ablehnen)
    // - Validation: status nur 'ausstehend' bei Create

    match /leihfahrzeugAnfragen/{anfrageId} {
      // Anfragende oder Besitzer-Werkstatt kann lesen
      allow read: if isAuthenticated()
                  && (
                    resource.data.anfragendeWerkstattId == request.auth.token.werkstattId
                    || resource.data.besitzerWerkstattId == request.auth.token.werkstattId
                  );

      // Anfragende Werkstatt kann erstellen (status muss 'ausstehend' sein)
      allow create: if isAuthenticated()
                    && (isAdmin() || isMitarbeiter())
                    && request.resource.data.anfragendeWerkstattId == request.auth.token.werkstattId
                    && request.resource.data.status == 'ausstehend';

      // Besitzer kann genehmigen/ablehnen (nur bestimmte Felder √§ndern)
      allow update: if isAuthenticated()
                    && (isAdmin() || isMitarbeiter())
                    && resource.data.besitzerWerkstattId == request.auth.token.werkstattId
                    && request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['status', 'genehmigungVon', 'genehmigungAm',
                                  'ablehnungsgrund', 'antwortNotiz']);

      // Anfragende Werkstatt kann stornieren (wenn noch ausstehend)
      allow update: if isAuthenticated()
                    && resource.data.anfragendeWerkstattId == request.auth.token.werkstattId
                    && resource.data.status == 'ausstehend'
                    && request.resource.data.status == 'storniert';

      // üß™ E2E Test Support
      allow read, write: if request.auth != null;
    }

    // ============================================
    // COUNTERS COLLECTION (Multi-Tenant) - 2025-11-11
    // ============================================
    // Stores global counters like invoice numbers (rechnungsnummer)
    // Pattern: counters_mosbach, counters_heidelberg
    // Documents: rechnungsnummer, etc.
    //
    // Security Requirements:
    // - Admin/Werkstatt: Full read/write access for counter management
    // - Mitarbeiter: Read-only access (for display purposes)
    // - Partner: NO ACCESS (counters are internal-only)
    //
    // Used by:
    // - kanban.html: generateUniqueRechnungsnummer() (automatic invoice creation)
    // - rechnungen-admin.html: manualCreateRechnung() (manual invoice creation)

    match /{countersCollection}/{counterId} {
      // ============================================
      // READ Rules
      // ============================================

      // Admin/Werkstatt: Full read access
      allow read: if countersCollection.matches('counters_.+')
                  && isAdmin();

      // Mitarbeiter (Active): Read-only access
      allow read: if countersCollection.matches('counters_.+')
                  && isMitarbeiter()
                  && isActive();

      // ============================================
      // WRITE Rules (Create/Update/Delete)
      // ============================================

      // Admin/Werkstatt: Full write access for counter updates
      // Used for incrementing invoice numbers via Firestore Transactions
      allow create, update: if countersCollection.matches('counters_.+')
                            && isAdmin();

      // Delete: Only admins (rarely needed, but available for cleanup)
      allow delete: if countersCollection.matches('counters_.+')
                    && isAdmin();
    }

    // ============================================
    // KALKULATION COLLECTIONS (Multi-Tenant) - 2025-11-29
    // ============================================
    // Interne Kostenvoranschl√§ge und Arbeitswert-Katalog
    // Pattern: kalkulation_saetze_mosbach, kalkulation_katalog_mosbach,
    //          kalkulation_material_mosbach, kalkulationen_mosbach
    //
    // Security Requirements:
    // - Admin/Werkstatt: Full read/write access
    // - Mitarbeiter (Active): Full read/write access (f√ºr Kalkulation erstellen)
    // - Partner: NO ACCESS (interne Collection)

    // Kalkulation S√§tze (Stundens√§tze, AW-Minuten, MwSt) - Config Document
    match /{kalkulationSaetzeCollection}/{docId} {
      // Admin/Werkstatt/Mitarbeiter: Full access
      allow read, write: if kalkulationSaetzeCollection.matches('kalkulation_saetze_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üß™ E2E Test Support
      allow read: if request.auth != null
                  && kalkulationSaetzeCollection.matches('kalkulation_saetze_.+');
      allow create, update: if request.auth != null
                            && kalkulationSaetzeCollection.matches('kalkulation_saetze_.+');
    }

    // Kalkulation Katalog (Arbeitswerte-Positionen)
    match /{kalkulationKatalogCollection}/{positionId} {
      // Admin/Werkstatt/Mitarbeiter: Full access
      allow read, write: if kalkulationKatalogCollection.matches('kalkulation_katalog_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üß™ E2E Test Support
      allow read: if request.auth != null
                  && kalkulationKatalogCollection.matches('kalkulation_katalog_.+');
      allow create, update: if request.auth != null
                            && kalkulationKatalogCollection.matches('kalkulation_katalog_.+');
      allow delete: if request.auth != null
                    && kalkulationKatalogCollection.matches('kalkulation_katalog_.+');
    }

    // Kalkulation Material (Material-Katalog mit Preisen)
    match /{kalkulationMaterialCollection}/{materialId} {
      // Admin/Werkstatt/Mitarbeiter: Full access
      allow read, write: if kalkulationMaterialCollection.matches('kalkulation_material_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üß™ E2E Test Support
      allow read: if request.auth != null
                  && kalkulationMaterialCollection.matches('kalkulation_material_.+');
      allow create, update: if request.auth != null
                            && kalkulationMaterialCollection.matches('kalkulation_material_.+');
      allow delete: if request.auth != null
                    && kalkulationMaterialCollection.matches('kalkulation_material_.+');
    }

    // Kalkulationen (Erstellte Kostenvoranschl√§ge)
    match /{kalkulationenCollection}/{kalkulationId} {
      // Admin/Werkstatt/Mitarbeiter: Full access
      allow read, write: if kalkulationenCollection.matches('kalkulationen_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üß™ E2E Test Support
      allow read: if request.auth != null
                  && kalkulationenCollection.matches('kalkulationen_.+');
      allow create, update: if request.auth != null
                            && kalkulationenCollection.matches('kalkulationen_.+');
      allow delete: if request.auth != null
                    && kalkulationenCollection.matches('kalkulationen_.+');
    }

    // ============================================
    // üÜï KALKULATION ZUS√ÑTZLICHE COLLECTIONS (2025-11-29)
    // ============================================

    // Kalkulation Templates (Schnell-Kalkulationen)
    // Pattern: kalkulation_templates_mosbach
    match /{kalkulationTemplatesCollection}/{templateId} {
      allow read, write: if kalkulationTemplatesCollection.matches('kalkulation_templates_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
      // üß™ E2E Test Support
      allow read: if request.auth != null
                  && kalkulationTemplatesCollection.matches('kalkulation_templates_.+');
      allow create, update, delete: if request.auth != null
                            && kalkulationTemplatesCollection.matches('kalkulation_templates_.+');
    }

    // Lieferanten (Lieferanten-Vergleich)
    // Pattern: lieferanten_mosbach
    match /{lieferantenCollection}/{lieferantId} {
      allow read, write: if lieferantenCollection.matches('lieferanten_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
      // üß™ E2E Test Support
      allow read: if request.auth != null
                  && lieferantenCollection.matches('lieferanten_.+');
      allow create, update, delete: if request.auth != null
                            && lieferantenCollection.matches('lieferanten_.+');
    }

    // Kalkulation Kunden (Wiederkehrende Kunden-Fahrzeuge)
    // Pattern: kalkulation_kunden_mosbach
    match /{kalkulationKundenCollection}/{kundeId} {
      allow read, write: if kalkulationKundenCollection.matches('kalkulation_kunden_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
      // üß™ E2E Test Support
      allow read: if request.auth != null
                  && kalkulationKundenCollection.matches('kalkulation_kunden_.+');
      allow create, update, delete: if request.auth != null
                            && kalkulationKundenCollection.matches('kalkulation_kunden_.+');
    }

    // Ersatzteile (Preis-Historie & Fahrzeug-Verkn√ºpfung)
    // Pattern: ersatzteile_mosbach
    match /{ersatzteileCollection}/{ersatzteilId} {
      allow read, write: if ersatzteileCollection.matches('ersatzteile_.+')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
      // üß™ E2E Test Support
      allow read: if request.auth != null
                  && ersatzteileCollection.matches('ersatzteile_.+');
      allow create, update, delete: if request.auth != null
                            && ersatzteileCollection.matches('ersatzteile_.+');
    }

    // ============================================
    // DEFAULT DENY - REMOVED (FIX #52)
    // ============================================

    // üêõ BUGFIX 2025-11-05: Removed global deny rule that was blocking ALL writes
    //
    // Previous code (REMOVED):
    //   match /{document=**} {
    //     allow read, write: if false;
    //   }
    //
    // Problem: This wildcard pattern matched EVERY path (including bonusAuszahlungen_mosbach)
    //          and created an explicit DENY that overrode ALL allow rules!
    //          Even "allow create: if true" failed because the global deny took precedence.
    //
    // Solution: Removed entirely - Firebase denies by default for unmatched paths.
    //           Specific rules above handle all authorized access.

    // ============================================
    // ‚úÖ BUG #2 FIX: RATE LIMITS COLLECTION (OpenAI API Rate Limiting)
    // Collection Pattern: rateLimits_{werkstattId}
    // Purpose: Track daily API usage (GPT-4, Whisper, TTS) per user
    // ============================================

    // Rate Limits: Mosbach
    match /rateLimits_mosbach/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow write: if false;
    }

    // Rate Limits: Heilbronn
    match /rateLimits_heilbronn/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow write: if false;
    }

    // Rate Limits: Sinsheim
    match /rateLimits_sinsheim/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow write: if false;
    }
  }
}
