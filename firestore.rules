rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // üÜï PHASE 2.1: Custom Claims Support mit Fallback
    // ============================================

    function isAuthenticated() {
      return request.auth != null;
    }

    // üÜï Priority 1: Custom Claims, Priority 2: Firestore Fallback
    function getUserRole() {
      // Try Custom Claims first (faster, no Firestore read), else Firestore
      return (request.auth.token != null && request.auth.token.role != null)
        ? request.auth.token.role
        : get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    // Status bleibt Firestore-basiert (Claims haben kein 'status' field)
    // üÜï FIX: exists()-Check f√ºr Partner ohne users/{uid}
    function getUserStatus() {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid))
        ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.status
        : 'active';  // Fallback f√ºr Partners mit Custom Claims aber ohne users/{uid}
    }

    function isAdmin() {
      return isAuthenticated() && (getUserRole() == 'admin' || getUserRole() == 'werkstatt' || getUserRole() == 'superadmin');
    }

    function isSuperAdmin() {
      return isAuthenticated() && getUserRole() == 'superadmin';
    }

    function isMitarbeiter() {
      // Check if a mitarbeiter is selected (via Custom Claims)
      // This allows werkstatt users to act as mitarbeiter while keeping werkstatt role
      return isAuthenticated() && request.auth.token.selectedMitarbeiterId != null;
    }

    function isPartner() {
      return isAuthenticated() && getUserRole() == 'partner';
    }

    function isKunde() {
      return isAuthenticated() && getUserRole() == 'kunde';
    }

    function isActive() {
      return getUserStatus() == 'active';
    }

    // üÜï Check ownership via Custom Claims partnerId OR uid
    function isOwner(partnerId) {
      // Priority 1: Custom Claims partnerId, Priority 2: Fallback to uid
      return isAuthenticated() &&
        ((request.auth.token != null && request.auth.token.partnerId != null)
          ? request.auth.token.partnerId == partnerId
          : request.auth.uid == partnerId);
    }

    // ============================================
    // üî• BONUS COLLECTIONS - MOVED TO TOP (FIX #53)
    // ============================================
    // CRITICAL: These rules MUST be at the TOP to prevent pattern collisions
    // Other wildcard patterns (/{chatCollection}/{id}, /{partnersCollection}/{id})
    // were matching BEFORE our bonus rules and blocking access!
    //
    // Strategy: Evaluate bonus rules FIRST, before ANY other wildcard patterns

    // 1. HARDCODED MOSBACH COLLECTION (most specific - checked first)
    match /bonusAuszahlungen_mosbach/{bonusId} {
      allow read, write: if true;  // üö® ULTRA-PERMISSIVE for debugging
    }

    // 2. MULTI-TENANT PATTERN (bonusAuszahlungen_mosbach, bonusAuszahlungen_heidelberg, etc.)
    match /{bonusCollection}/{bonusId} {
      // Ultra-permissive for debugging - allows ALL operations on bonus collections
      allow read, write: if bonusCollection.matches('bonusAuszahlungen_.*');

      // Admin/Mitarbeiter/Partner specific rules (currently redundant due to above rule)
      // Will be re-enabled after debugging is complete:
      // allow read, write: if bonusCollection.matches('bonusAuszahlungen_.*') && isAdmin();
      // allow read: if bonusCollection.matches('bonusAuszahlungen_.*') && isMitarbeiter() && isActive();
      // allow read: if bonusCollection.matches('bonusAuszahlungen_.*') && request.auth != null
      //             && resource.data.partnerEmail == request.auth.token.email;
    }

    // ============================================
    // üìö WISSENSDATENBANK (Knowledge Base) - NEW 2025-11-08
    // ============================================
    // Three collections for guidelines, announcements, and shift handovers
    // Multi-tenant pattern: guidelines_mosbach, announcements_mosbach, shift_handovers_mosbach, etc.

    // 1. GUIDELINES COLLECTION (SOPs, Richtlinien, Prozesse)
    match /{guidelinesCollection}/{guidelineId} {
      // Read: All authenticated users can read guidelines
      allow read: if isAuthenticated()
                  && guidelinesCollection.matches('guidelines_.*')
                  && request.auth.token.werkstattId == guidelinesCollection.split('_')[1];

      // Create/Update/Delete: Only admins and werkstatt users
      allow create, update, delete: if isAdmin()
                  && guidelinesCollection.matches('guidelines_.*')
                  && request.auth.token.werkstattId == guidelinesCollection.split('_')[1]
                  && request.resource.data.keys().hasAll([
                      'title', 'category', 'content', 'createdBy', 'createdAt'
                  ]);
    }

    // 2. ANNOUNCEMENTS COLLECTION (Team communication, updates)
    match /{announcementsCollection}/{announcementId} {
      // Read: All authenticated users can read announcements
      allow read: if isAuthenticated()
                  && announcementsCollection.matches('announcements_.*')
                  && request.auth.token.werkstattId == announcementsCollection.split('_')[1];

      // Create/Update/Delete: Only admins and werkstatt users
      allow create, update, delete: if isAdmin()
                  && announcementsCollection.matches('announcements_.*')
                  && request.auth.token.werkstattId == announcementsCollection.split('_')[1]
                  && request.resource.data.keys().hasAll([
                      'title', 'category', 'content', 'author', 'timestamp'
                  ]);

      // Update reactions and comments: All authenticated users
      allow update: if isAuthenticated()
                  && announcementsCollection.matches('announcements_.*')
                  && request.auth.token.werkstattId == announcementsCollection.split('_')[1]
                  && (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions', 'comments', 'readBy']));
    }

    // 3. SHIFT HANDOVERS COLLECTION (Schicht√ºbergaben)
    match /{handoversCollection}/{handoverId} {
      // Read: All authenticated users can read handovers
      allow read: if isAuthenticated()
                  && handoversCollection.matches('shift_handovers_.*')
                  && request.auth.token.werkstattId == handoversCollection.split('_')[1];

      // Create: Employees creating their own handovers
      allow create: if isAuthenticated()
                  && handoversCollection.matches('shift_handovers_.*')
                  && request.auth.token.werkstattId == handoversCollection.split('_')[1]
                  && request.resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

      // Update/Delete: Only admins can edit/delete handovers
      allow update, delete: if isAdmin()
                  && handoversCollection.matches('shift_handovers_.*')
                  && request.auth.token.werkstattId == handoversCollection.split('_')[1];
    }

    // ============================================
    // ACTIVE SESSIONS (Multi-Tab Monitoring)
    // ============================================
    // Multi-tenant pattern: activeSessions_mosbach, activeSessions_heidelberg, etc.
    // Tracks active employee logins for real-time dashboard monitoring

    match /{activeSessionsCollection}/{sessionId} {
      // Pattern match for activeSessions_* collections
      allow create: if activeSessionsCollection.matches('activeSessions_.*')
                    && isAuthenticated()
                    && request.resource.data.werkstattId == activeSessionsCollection.split('_')[1]
                    && request.resource.data.status == 'active'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'werkstattId',
                        'loginTime', 'lastActivity', 'status'
                    ]);

      // Mitarbeiter can update their own session (heartbeat)
      allow update: if activeSessionsCollection.matches('activeSessions_.*')
                    && isAuthenticated()
                    && resource.data.mitarbeiterId == request.auth.uid;

      // Mitarbeiter can delete their own session (logout)
      allow delete: if activeSessionsCollection.matches('activeSessions_.*')
                    && isAuthenticated()
                    && resource.data.mitarbeiterId == request.auth.uid;

      // üÜï FIX 2025-11-07: Use Custom Claims for query-compatible access check
      // Werkstatt & Admin can read all sessions (for monitoring dashboard)
      // CRITICAL: Uses request.auth.token (Custom Claims) instead of get()
      // to avoid "Missing or insufficient permissions" during query evaluation
      allow read: if activeSessionsCollection.matches('activeSessions_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                    || request.auth.token.role == 'mitarbeiter'
                  );
    }

    // ============================================
    // SERVICE-SESSIONS COLLECTION (Multi-Tenant)
    // Phase 1.2 - Dienstplan Feature
    // Tracks which services (Lackierung, Mechanik, etc.) each employee is working on
    // ============================================

    match /{serviceSessionsCollection}/{sessionId} {
      // Mitarbeiter can create their own service sessions
      // VALIDATION: Ensures werkstattId matches, mitarbeiterId is current user, status is 'active'
      allow create: if serviceSessionsCollection.matches('serviceSessions_.*')
                    && isAuthenticated()
                    && request.resource.data.werkstattId == serviceSessionsCollection.split('_')[1]
                    && request.resource.data.mitarbeiterId == request.auth.uid
                    && request.resource.data.status == 'active'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'service',
                        'werkstattId', 'loginTime', 'status'
                    ]);

      // Mitarbeiter can read/update their own sessions
      allow read, update: if serviceSessionsCollection.matches('serviceSessions_.*')
                          && isAuthenticated()
                          && resource.data.mitarbeiterId == request.auth.uid;

      // Mitarbeiter can delete their own sessions (logout)
      allow delete: if serviceSessionsCollection.matches('serviceSessions_.*')
                    && isAuthenticated()
                    && resource.data.mitarbeiterId == request.auth.uid;

      // üÜï Use Custom Claims for query-compatible access check
      // Werkstatt & Admin can read all sessions (for monitoring dashboard)
      // CRITICAL: Uses request.auth.token (Custom Claims) instead of get()
      allow read: if serviceSessionsCollection.matches('serviceSessions_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                    || request.auth.token.role == 'mitarbeiter'
                  );
    }

    // ============================================
    // URLAUBS-ANFRAGEN COLLECTION (Multi-Tenant)
    // Phase 2.1 - Dienstplan Feature (Vacation Requests)
    // Mitarbeiter k√∂nnen Urlaub anfragen, Admin kann genehmigen/ablehnen
    // ============================================

    match /{urlaubsAnfragenCollection}/{anfrageId} {
      // Mitarbeiter can create their own vacation requests
      // VALIDATION: Ensures werkstattId matches, mitarbeiterId is current user, status is 'pending'
      // Uses Custom Claims mitarbeiterId (2-Stage Auth: Werkstatt Login ‚Üí Mitarbeiter Selection)
      allow create: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.*')
                    && isAuthenticated()
                    && isMitarbeiter()
                    && isActive()
                    && request.resource.data.werkstattId == urlaubsAnfragenCollection.split('_')[1]
                    && request.resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && request.resource.data.status == 'pending'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'startDatum', 'endDatum',
                        'anzahlTage', 'grund', 'status', 'werkstattId', 'createdAt'
                    ]);

      // Mitarbeiter can read their own requests
      // Uses Custom Claims mitarbeiterId (2-Stage Auth: Werkstatt Login ‚Üí Mitarbeiter Selection)
      allow read: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.*')
                  && isAuthenticated()
                  && isMitarbeiter()
                  && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

      // Werkstatt & Admin can read all requests (for admin panel)
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow read: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                    || getUserRole() == 'werkstatt'
                    || getUserRole() == 'admin'
                    || getUserRole() == 'superadmin'
                  );

      // Admin can update requests (approve/reject)
      // VALIDATION: Only status, bearbeitetVon, bearbeitetAm, ablehnungsgrund can be changed
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow update: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                      || getUserRole() == 'werkstatt'
                      || getUserRole() == 'admin'
                      || getUserRole() == 'superadmin'
                    )
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                        'status', 'bearbeitetVon', 'bearbeitetAm', 'ablehnungsgrund'
                    ])
                    && (
                      request.resource.data.status == 'approved'
                      || request.resource.data.status == 'rejected'
                    );

      // Mitarbeiter can delete their own pending requests
      // USES CUSTOM CLAIMS: request.auth.token.selectedMitarbeiterId
      allow delete: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.*')
                    && isAuthenticated()
                    && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && resource.data.status == 'pending';

      // Admin can delete any request
      allow delete: if urlaubsAnfragenCollection.matches('urlaubsAnfragen_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );
    }

    // ============================================
    // SCHICHT-TYPEN COLLECTION (Multi-Tenant)
    // Phase 2.2 - Dienstplan Feature (Shift Types)
    // Admin erstellt Schicht-Typen (z.B. Fr√ºhschicht 6-14h, Sp√§tschicht 14-22h)
    // ============================================

    match /{schichtTypenCollection}/{schichtTypId} {
      // Admin/Werkstatt: Full access (CRUD)
      allow create, read, update, delete: if schichtTypenCollection.matches('schichtTypen_.*')
                                          && isAuthenticated()
                                          && (
                                            request.auth.token.role == 'werkstatt'
                                            || request.auth.token.role == 'admin'
                                            || request.auth.token.role == 'superadmin'
                                          );

      // Mitarbeiter: Read-only (k√∂nnen Schicht-Typen sehen)
      allow read: if schichtTypenCollection.matches('schichtTypen_.*')
                  && isMitarbeiter()
                  && isActive();
    }

    // ============================================
    // SCHICHTEN COLLECTION (Multi-Tenant)
    // Phase 2.2 - Dienstplan Feature (Shift Assignments)
    // Admin weist Mitarbeiter zu Schichten zu
    // ============================================

    match /{schichtenCollection}/{schichtId} {
      // Admin/Werkstatt: Full access (CRUD)
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow create, read, update, delete: if schichtenCollection.matches('schichten_.*')
                                          && isAuthenticated()
                                          && (
                                            request.auth.token.role == 'werkstatt'
                                            || request.auth.token.role == 'admin'
                                            || request.auth.token.role == 'superadmin'
                                            || getUserRole() == 'werkstatt'
                                            || getUserRole() == 'admin'
                                            || getUserRole() == 'superadmin'
                                          );

      // RELAXED: Allow werkstatt OR mitarbeiter role to read all schichten
      // This allows SessionStorage-based mitarbeiter sessions (without Custom Claims)
      // to still access schichten via werkstatt role
      allow read: if schichtenCollection.matches('schichten_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'mitarbeiter'
                  );
    }

    // ============================================
    // SCHICHT-W√úNSCHE COLLECTION (Multi-Tenant)
    // Phase 2.2 - Dienstplan Feature (Shift Preferences)
    // Mitarbeiter k√∂nnen W√ºnsche √§u√üern (bevorzugt/nicht verf√ºgbar)
    // ============================================

    match /{schichtWuenscheCollection}/{wunschId} {
      // Mitarbeiter: Create own w√ºnsche
      // VALIDATION: werkstattId match, mitarbeiterId is current user, status is 'pending'
      allow create: if schichtWuenscheCollection.matches('schichtWuensche_.*')
                    && isAuthenticated()
                    && isMitarbeiter()
                    && isActive()
                    && request.resource.data.werkstattId == schichtWuenscheCollection.split('_')[1]
                    && request.resource.data.mitarbeiterId == request.auth.uid
                    && request.resource.data.status == 'pending'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'datum', 'praeferenz',
                        'grund', 'status', 'werkstattId', 'createdAt'
                    ]);

      // Mitarbeiter: Read own w√ºnsche
      allow read: if schichtWuenscheCollection.matches('schichtWuensche_.*')
                  && isMitarbeiter()
                  && isActive()
                  && resource.data.mitarbeiterId == request.auth.uid;

      // Admin/Werkstatt: Read all w√ºnsche from their werkstatt
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow read: if schichtWuenscheCollection.matches('schichtWuensche_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                    || getUserRole() == 'werkstatt'
                    || getUserRole() == 'admin'
                    || getUserRole() == 'superadmin'
                  )
                  && resource.data.werkstattId == schichtWuenscheCollection.split('_')[1];

      // Admin/Werkstatt: Update w√ºnsche (accept/reject)
      // VALIDATION: Only status, bearbeitetAm can be changed
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow update: if schichtWuenscheCollection.matches('schichtWuensche_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                      || getUserRole() == 'werkstatt'
                      || getUserRole() == 'admin'
                      || getUserRole() == 'superadmin'
                    )
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                        'status', 'bearbeitetAm'
                    ])
                    && (
                      request.resource.data.status == 'accepted'
                      || request.resource.data.status == 'rejected'
                    );

      // Mitarbeiter: Delete own pending w√ºnsche
      allow delete: if schichtWuenscheCollection.matches('schichtWuensche_.*')
                    && isMitarbeiter()
                    && isActive()
                    && resource.data.mitarbeiterId == request.auth.uid
                    && resource.data.status == 'pending';

      // Admin: Delete any wunsch
      allow delete: if schichtWuenscheCollection.matches('schichtWuensche_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );
    }

    // ============================================
    // SCHICHT-TAUSCHE COLLECTION (Multi-Tenant)
    // Phase 2.2 - Dienstplan Feature (Shift Swaps)
    // Mitarbeiter k√∂nnen Schicht-Tausch anfragen, Admin genehmigt
    // ============================================

    match /{schichtTauscheCollection}/{tauschId} {
      // Mitarbeiter: Create tausch-anfrage
      // RELAXED: Allows werkstatt role (for SessionStorage-based mitarbeiter login)
      // Custom Claims check is optional (only if setMitarbeiterClaims was called)
      allow create: if schichtTauscheCollection.matches('schichtTausche_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'mitarbeiter'
                    )
                    && request.resource.data.werkstattId == schichtTauscheCollection.split('_')[1]
                    && request.resource.data.status == 'pending'
                    && request.resource.data.keys().hasAll([
                        'mitarbeiter1Id', 'mitarbeiter1Name', 'schicht1Id', 'schicht1Datum', 'schicht1Typ',
                        'mitarbeiter2Id', 'mitarbeiter2Name', 'schicht2Id', 'schicht2Datum', 'schicht2Typ',
                        'nachricht', 'status', 'werkstattId', 'createdAt'
                    ]);

      // Mitarbeiter: Read own tausch-anfragen (mitarbeiter1 or mitarbeiter2)
      // RELAXED: Uses Custom Claims mitarbeiterId if available, otherwise allows all from same werkstatt
      allow read: if schichtTauscheCollection.matches('schichtTausche_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'mitarbeiter'
                  )
                  && (
                    resource.data.werkstattId == schichtTauscheCollection.split('_')[1]
                  );

      // Admin/Werkstatt: Read all tausch-anfragen
      allow read: if schichtTauscheCollection.matches('schichtTausche_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                  );

      // Admin/Werkstatt: Update tausch-anfragen (approve/reject)
      // VALIDATION: Only status, bearbeitetAm can be changed
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow update: if schichtTauscheCollection.matches('schichtTausche_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                      || getUserRole() == 'werkstatt'
                      || getUserRole() == 'admin'
                      || getUserRole() == 'superadmin'
                    )
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                        'status', 'bearbeitetAm'
                    ])
                    && (
                      request.resource.data.status == 'approved'
                      || request.resource.data.status == 'rejected'
                    );

      // Mitarbeiter: Delete own pending tausch-anfragen
      // RELAXED: Allows deletion from same werkstatt if status is pending
      allow delete: if schichtTauscheCollection.matches('schichtTausche_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'mitarbeiter'
                    )
                    && resource.data.werkstattId == schichtTauscheCollection.split('_')[1]
                    && resource.data.status == 'pending';

      // Admin: Delete any tausch-anfrage
      allow delete: if schichtTauscheCollection.matches('schichtTausche_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );
    }

    // ============================================
    // BEREICHE COLLECTION (Multi-Tenant)
    // Phase 2025-11-07 - Dienstplan Feature (Work Areas/Departments)
    // Admin erstellt Bereiche (z.B. Lackierung, Mechanik, Karosserie)
    // ============================================

    match /{bereicheCollection}/{bereichId} {
      // Admin/Werkstatt: Full access (CRUD)
      allow create, read, update, delete: if bereicheCollection.matches('bereiche_.*')
                                          && isAuthenticated()
                                          && (
                                            request.auth.token.role == 'werkstatt'
                                            || request.auth.token.role == 'admin'
                                            || request.auth.token.role == 'superadmin'
                                          );

      // Mitarbeiter: Read-only (k√∂nnen Bereiche sehen)
      allow read: if bereicheCollection.matches('bereiche_.*')
                  && isMitarbeiter()
                  && isActive();
    }

    // ============================================
    // STUNDENNACHWEISE COLLECTION (Multi-Tenant)
    // Phase 3.4 - Mitarbeiter-Dienstplan (Hour Records/Timesheets)
    // Mitarbeiter erstellen Stundennachweise, Admin genehmigt sie
    // ============================================

    match /{stundennachweiselCollection}/{nachweisId} {
      // Mitarbeiter can create their own hour records (status='draft')
      // USES CUSTOM CLAIMS: request.auth.token.selectedMitarbeiterId
      allow create: if stundennachweiselCollection.matches('stundennachweise_.*')
                    && isAuthenticated()
                    && request.auth.token.selectedMitarbeiterId != null
                    && request.resource.data.werkstattId == stundennachweiselCollection.split('_')[1]
                    && request.resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && request.resource.data.keys().hasAll([
                        'mitarbeiterId', 'mitarbeiterName', 'monat', 'jahr',
                        'zeitraum', 'signiert', 'stundenGesamt', 'werkstattId', 'createdAt'
                    ]);

      // Mitarbeiter can read their own records
      // USES CUSTOM CLAIMS: request.auth.token.selectedMitarbeiterId
      allow read: if stundennachweiselCollection.matches('stundennachweise_.*')
                  && isAuthenticated()
                  && request.auth.token.selectedMitarbeiterId != null
                  && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

      // Admin/Werkstatt can read all records (for admin panel)
      allow read: if stundennachweiselCollection.matches('stundennachweise_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'admin'
                    || request.auth.token.role == 'superadmin'
                  );

      // Admin/Werkstatt can delete records
      allow delete: if stundennachweiselCollection.matches('stundennachweise_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );

      // Anmerkungen Subcollection (Nested within stundennachweise)
      match /anmerkungen/{anmerkungId} {
        // Mitarbeiter can create anmerkungen for their own records
        // Parent document check: Ensure the stundennachweis belongs to the mitarbeiter
        allow create: if stundennachweiselCollection.matches('stundennachweise_.*')
                      && isAuthenticated()
                      && request.auth.token.selectedMitarbeiterId != null
                      && get(/databases/$(database)/documents/$(stundennachweiselCollection)/$(nachweisId)).data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                      && request.resource.data.keys().hasAll([
                          'datum', 'fehlertyp', 'beschreibung', 'createdAt'
                      ]);

        // Mitarbeiter can read anmerkungen for their own records
        allow read: if stundennachweiselCollection.matches('stundennachweise_.*')
                    && isAuthenticated()
                    && request.auth.token.selectedMitarbeiterId != null
                    && get(/databases/$(database)/documents/$(stundennachweiselCollection)/$(nachweisId)).data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

        // Admin/Werkstatt can read all anmerkungen
        allow read: if stundennachweiselCollection.matches('stundennachweise_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'
                      || request.auth.token.role == 'admin'
                      || request.auth.token.role == 'superadmin'
                    );

        // Mitarbeiter can delete their own anmerkungen
        allow delete: if stundennachweiselCollection.matches('stundennachweise_.*')
                      && isAuthenticated()
                      && request.auth.token.selectedMitarbeiterId != null
                      && get(/databases/$(database)/documents/$(stundennachweiselCollection)/$(nachweisId)).data.mitarbeiterId == request.auth.token.selectedMitarbeiterId;

        // Admin/Werkstatt can delete any anmerkungen
        allow delete: if stundennachweiselCollection.matches('stundennachweise_.*')
                      && isAuthenticated()
                      && (
                        request.auth.token.role == 'werkstatt'
                        || request.auth.token.role == 'admin'
                        || request.auth.token.role == 'superadmin'
                      );
      }
    }

    // ============================================
    // USERS COLLECTION
    // ============================================

    match /users/{userId} {
      // Self-Service Registration (no auth required)
      // Users can create their own account with status='pending'
      allow create: if request.resource.data.status == 'pending'
                    && request.resource.data.uid == request.auth.uid;

      // Admins (werkstatt, admin, superadmin) can create any user accounts
      // This allows Owner accounts to create new werkstatt accounts via setup-werkstatt.html
      allow create: if isAdmin();

      // üÜï Allow werkstatt accounts to create their own initial document (setup-werkstatt.html)
      // This is needed because createUserWithEmailAndPassword() auto-logs in as the NEW account
      // Strict validation ensures only properly formatted werkstatt documents can be created
      allow create: if request.auth.uid == userId
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.role == 'werkstatt'
                    && request.resource.data.status == 'active'
                    && request.resource.data.keys().hasAll(['uid', 'email', 'name', 'werkstattId', 'role', 'status', 'isOwner', 'adresse', 'createdAt', 'createdBy']);

      // Users can read their own data
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // Admins can read/write all users
      allow read, write: if isAdmin();

      // Mitarbeiter can read all users (but not write)
      allow read: if isMitarbeiter();

      // Users can update their own lastLogin
      allow update: if isAuthenticated()
                    && request.auth.uid == userId
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastLogin']);
    }

    // ============================================
    // PARTNERS COLLECTION (Global - for pending registrations)
    // üÜï Multi-Tenant Registration System: Partners register ‚Üí Admin assigns werkstattId
    // ============================================

    match /partners/{partnerId} {
      // üÜï Self-Service Registration: Authenticated users can create with status='pending'
      allow create: if isAuthenticated()
                    && request.resource.data.status == 'pending'
                    && request.resource.data.partnerId == request.auth.uid
                    && request.resource.data.werkstattId == null
                    && request.resource.data.keys().hasAll(['partnerId', 'kundenname', 'email', 'plz', 'stadt', 'region', 'status', 'createdAt']);

      // Admins: Full access (for pending-registrations.html approval)
      allow read, write: if isAdmin();

      // Partners: Can read ONLY their own document (even when pending)
      allow read: if isAuthenticated() && isOwner(partnerId);

      // Partners: Can update specific fields after being assigned & active
      allow update: if isPartner()
                    && isActive()
                    && isOwner(partnerId)
                    && request.resource.data.diff(resource.data)
                        .affectedKeys()
                        .hasOnly(['lastLogin', 'requiresPasswordChange', 'passwordChangedAt', 'initialPassword']);
    }

    // ============================================
    // FAHRZEUGE COLLECTION (Anfragen)
    // ‚ö†Ô∏è DEPRECATED: Use fahrzeuge_mosbach, fahrzeuge_heidelberg, etc. instead
    // This rule exists ONLY for legacy data migration
    // See Multi-Tenant Collections (Line 208) for active rules
    // ============================================

    match /fahrzeuge/{requestId} {
      // Admins: Full access to all requests
      allow read, write: if isAdmin();

      // Mitarbeiter: Can read all, can update assigned requests
      allow read: if (isMitarbeiter() && isActive());
      allow update: if (isMitarbeiter() && isActive());
      allow create: if (isMitarbeiter() && isActive());

      // Partner: Can only access their own requests
      allow read: if isPartner() && isActive() && isOwner(resource.data.partnerId);
      allow create: if isPartner() && isActive();
      allow update: if isPartner() && isActive() && isOwner(resource.data.partnerId);

      // Kunde: Read-only access to their own requests
      allow read: if isKunde() && isActive() && isOwner(resource.data.partnerId);

      // Subcollections: Fotos
      match /fotos/{photoId} {
        // Admins: Full access
        allow read, write: if isAdmin();

        // Mitarbeiter: Full access
        allow read, write: if isMitarbeiter() && isActive();

        // Partner: Can read/write their own photos
        allow read, write: if isPartner() && isActive()
                           && isOwner(get(/databases/$(database)/documents/fahrzeuge/$(requestId)).data.partnerId);

        // Kunde: Read-only access to their photos
        allow read: if isKunde() && isActive()
                    && isOwner(get(/databases/$(database)/documents/fahrzeuge/$(requestId)).data.partnerId);
      }
    }

    // ============================================
    // KUNDEN COLLECTION
    // ‚ö†Ô∏è DEPRECATED: Use kunden_mosbach, kunden_heidelberg, etc. instead
    // This rule exists ONLY for legacy data migration
    // See Multi-Tenant Collections (Line 220) for active rules
    // ============================================

    match /kunden/{kundeId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access
      allow read, write: if (isMitarbeiter() && isActive());

      // Partner: Can read customers they've registered
      allow read: if isPartner() && isActive() && isOwner(resource.data.partnerId);
      allow create: if isPartner() && isActive();

      // Kunde: Can read their own data
      allow read: if isKunde() && isActive() && isOwner(resource.data.uid);
    }

    // ============================================
    // MATERIAL COLLECTION (Bestellungen)
    // ‚ö†Ô∏è DEPRECATED: Use materialRequests_mosbach, etc. instead
    // This rule exists ONLY for legacy data migration
    // See Multi-Tenant Collections (Line 240) for active rules
    // ============================================

    match /material/{materialId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access
      allow read, write: if (isMitarbeiter() && isActive());

      // Partner: No access (internal only)
      allow read, write: if false;
    }

    // ============================================
    // KALENDER COLLECTION (Termine)
    // ‚ö†Ô∏è DEPRECATED: Use kalender_mosbach, kalender_heidelberg, etc. instead
    // This rule exists ONLY for legacy data migration
    // See Multi-Tenant Collections (Line 233) for active rules
    // ============================================

    match /kalender/{terminId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access
      allow read, write: if (isMitarbeiter() && isActive());

      // Partner: Can read appointments related to their requests
      allow read: if isPartner() && isActive() && isOwner(resource.data.partnerId);
    }

    // ============================================
    // CHATS COLLECTION (KI Chat - Coming Soon)
    // ============================================

    match /chats/{chatId} {
      // Users can only read/write their own chats
      allow read, write: if isAuthenticated() && isActive() && request.auth.uid == resource.data.userId;

      // Admins can read all chats (for moderation)
      allow read: if isAdmin();
    }

    // ============================================
    // EMAIL_LOGS COLLECTION (Cloud Functions only)
    // ============================================

    match /email_logs/{logId} {
      // Admins can read email logs for debugging
      allow read: if isAdmin();

      // ONLY Cloud Functions can write (deny all user writes)
      allow write: if false;
    }

    // ============================================
    // AI_LOGS COLLECTION (Cloud Functions only)
    // ============================================

    match /ai_logs/{logId} {
      // Admins can read AI Agent logs for debugging
      allow read: if isAdmin();

      // ONLY Cloud Functions can write (deny all user writes)
      allow write: if false;
    }

    // ============================================
    // WHISPER_LOGS COLLECTION (Cloud Functions only)
    // ============================================

    match /whisper_logs/{logId} {
      // Admins can read Whisper transcription logs for debugging
      allow read: if isAdmin();

      // ONLY Cloud Functions can write (deny all user writes)
      allow write: if false;
    }

    // ============================================
    // GLOBAL CHAT COLLECTION (f√ºr Werkstatt-Benachrichtigungen)
    // ============================================

    match /globalChat/{messageId} {
      // Admins und Mitarbeiter k√∂nnen globale Chat-Nachrichten lesen/schreiben
      allow read, write: if (isAdmin() || isMitarbeiter()) && isActive();

      // Werkstatt-Rolle kann ebenfalls lesen/schreiben (f√ºr Multi-Tenant)
      allow read, write: if isAuthenticated() && getUserRole() == 'werkstatt' && isActive();
    }

    // ============================================
    // MULTI-TENANT COLLECTIONS (werkstatt-specific)
    // Using wildcard pattern: /{collection}_{werkstatt}/{docId}
    // ============================================

    // Fahrzeuge Collections: fahrzeuge_mosbach, fahrzeuge_heidelberg, etc.
    match /{fahrzeugeCollection}/{vehicleId} {
      allow read, write: if fahrzeugeCollection.matches('fahrzeuge_.*')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üÜï BUGFIX 2025-11-04 (FIX #26, #33): Partners k√∂nnen ihre eigenen Fahrzeuge lesen
      // Security: Email-basiert (Direct Matching only - Cross-Collection-Check entfernt)
      // Removed komplexen partnerId Fallback der zu Permission Errors f√ºhrte
      allow read: if fahrzeugeCollection.matches('fahrzeuge_.*')
                  && request.auth != null
                  && (
                    resource.data.partnerEmail == request.auth.token.email
                    || resource.data.kundenEmail == request.auth.token.email
                  );

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Fahrzeuge erstellen (f√ºr KVA-Annahme)
      // Security: Partner kann nur Fahrzeuge mit seiner eigenen Email erstellen
      allow create: if fahrzeugeCollection.matches('fahrzeuge_.*')
                    && isPartner()
                    && isActive()
                    && (
                      request.resource.data.partnerEmail == request.auth.token.email
                      || request.resource.data.kundenEmail == request.auth.token.email
                    );

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Fahrzeuge abfragen (f√ºr Duplicate-Check + loadFahrzeugByAuftragsnummer)
      // Security: Bestehende READ-Regel (Zeile 329-334) filtert Ergebnisse auf eigene Fahrzeuge
      allow list: if fahrzeugeCollection.matches('fahrzeuge_.*')
                  && isPartner()
                  && isActive();

      // Subcollections: Fotos
      match /fotos/{photoId} {
        allow read, write: if fahrzeugeCollection.matches('fahrzeuge_.*')
                           && (isAdmin() || (isMitarbeiter() && isActive()));

        // üÜï BUGFIX 2025-11-04 (v2): Partners k√∂nnen Fotos ihrer eigenen Fahrzeuge lesen
        // Security: Email-basiert (kein Custom Claims check mehr)
        allow read: if fahrzeugeCollection.matches('fahrzeuge_.*')
                    && request.auth != null
                    && (
                      get(/databases/$(database)/documents/$(fahrzeugeCollection)/$(vehicleId)).data.partnerEmail == request.auth.token.email
                      || get(/databases/$(database)/documents/$(fahrzeugeCollection)/$(vehicleId)).data.kundenEmail == request.auth.token.email
                    );

        // üÜï BUGFIX 2025-11-05: Partners k√∂nnen Fotos ihrer eigenen Fahrzeuge hochladen
        // Security: Email-basiert + isPartner() + isActive() checks
        allow write: if fahrzeugeCollection.matches('fahrzeuge_.*')
                     && isPartner()
                     && isActive()
                     && (
                       get(/databases/$(database)/documents/$(fahrzeugeCollection)/$(vehicleId)).data.partnerEmail == request.auth.token.email
                       || get(/databases/$(database)/documents/$(fahrzeugeCollection)/$(vehicleId)).data.kundenEmail == request.auth.token.email
                     );
      }
    }

    // Kunden Collections: kunden_mosbach, kunden_heidelberg, etc.
    match /{kundenCollection}/{kundeId} {
      allow read, write: if kundenCollection.matches('kunden_.*')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Kunden erstellen (f√ºr KVA-Annahme)
      // Security: Partner kann nur Kunden mit seiner eigenen Email erstellen
      allow create: if kundenCollection.matches('kunden_.*')
                    && isPartner()
                    && isActive()
                    && request.resource.data.email == request.auth.token.email;

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen Kunden-Queries machen (f√ºr registriereKundenbesuch)
      // Security: Query erlaubt, aber nur Kunden mit Partner-Email werden zur√ºckgegeben
      allow list: if kundenCollection.matches('kunden_.*')
                  && isPartner()
                  && isActive();

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen eigene Kunden updaten (f√ºr Besuchs-Registrierung)
      // Security: Email-basierte Validierung - Partner kann nur Kunden mit seiner Email updaten
      allow update: if kundenCollection.matches('kunden_.*')
                    && isPartner()
                    && isActive()
                    && resource.data.email == request.auth.token.email
                    && request.resource.data.email == request.auth.token.email;
    }

    // Mitarbeiter Collections: mitarbeiter_mosbach, mitarbeiter_heidelberg, etc.
    match /{mitarbeiterCollection}/{mitarbeiterId} {
      allow read, write: if mitarbeiterCollection.matches('mitarbeiter_.*') && isAdmin();

      // RELAXED: Allow werkstatt OR mitarbeiter role to read all mitarbeiter
      // This allows SessionStorage-based mitarbeiter sessions (without Custom Claims)
      // to still load team data via werkstatt role
      allow read: if mitarbeiterCollection.matches('mitarbeiter_.*')
                  && isAuthenticated()
                  && (
                    request.auth.token.role == 'werkstatt'
                    || request.auth.token.role == 'mitarbeiter'
                  );

      // üÜï CRITICAL FIX: Allow werkstatt to update lastLogin field ONLY
      // Required for Mitarbeiter-Login flow (auth-manager.js:341)
      // Security: Only lastLogin field can be modified, nothing else
      // Uses Custom Claims (Priority 1) or Firestore fallback (Priority 2)
      allow update: if mitarbeiterCollection.matches('mitarbeiter_.*')
                    && isAuthenticated()
                    && (
                      request.auth.token.role == 'werkstatt'  // Custom Claims (Priority 1)
                      || getUserRole() == 'werkstatt'  // Firestore Fallback (Priority 2)
                    )
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastLogin']);

      allow create, delete: if mitarbeiterCollection.matches('mitarbeiter_.*') && isAdmin();

      // üÜï Allow werkstatt accounts to create _init placeholder during setup
      // This is needed because setup-werkstatt.html auto-logs in as the NEW account
      // Only allows creation of the special _init document, not actual mitarbeiter records
      allow create: if mitarbeiterCollection.matches('mitarbeiter_.*')
                    && mitarbeiterId == '_init'
                    && isAuthenticated()
                    && request.resource.data.keys().hasOnly(['info', 'createdAt']);
    }

    // Kalender Collections: kalender_mosbach, kalender_heidelberg, etc.
    match /{kalenderCollection}/{terminId} {
      allow read, write: if kalenderCollection.matches('kalender_.*')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
      allow read: if kalenderCollection.matches('kalender_.*') && isPartner() && isActive() && isOwner(resource.data.partnerId);
    }

    // Material Requests Collections: materialRequests_mosbach, etc.
    match /{materialCollection}/{requestId} {
      allow read, write: if materialCollection.matches('materialRequests_.*')
                         && (isAdmin() || (isMitarbeiter() && isActive()));
    }

    // Einstellungen Collections: einstellungen_mosbach, etc.
    match /{einstellungenCollection}/{docId} {
      allow read, write: if einstellungenCollection.matches('einstellungen_.*') && isAdmin();
      allow read: if einstellungenCollection.matches('einstellungen_.*') && isMitarbeiter() && isActive();
    }

    // Partners Collections: partners_mosbach, partners_heidelberg, etc.
    match /{partnersCollection}/{partnerId} {
      // Admins & Mitarbeiter: Full access
      allow read, write: if partnersCollection.matches('partners_.*')
                         && (isAdmin() || (isMitarbeiter() && isActive()));

      // Partners: Can read ONLY their own document
      allow read: if partnersCollection.matches('partners_.*')
                  && isPartner()
                  && isActive()
                  && isOwner(partnerId);

      // Partners: Can update password-related fields + bonus-fields
      // üÜï BUGFIX 2025-11-06: Added bonus-related fields f√ºr KVA-Annahme
      allow update: if partnersCollection.matches('partners_.*')
                    && isPartner()
                    && isActive()
                    && isOwner(partnerId)
                    && request.resource.data.diff(resource.data)
                        .affectedKeys()
                        .hasOnly(['requiresPasswordChange', 'passwordChangedAt', 'initialPassword', 'lastLogin', 'bonusErhalten', 'rabattKonditionen']);
    }

    // Global Partner Collection (used by Cloud Functions for Auth data)
    match /partner/{partnerId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Partners: Can read ONLY their own document
      allow read: if isPartner() && isActive() && isOwner(partnerId);

      // Partners: Can update specific fields (last login tracking + password change)
      allow update: if isPartner()
                    && isActive()
                    && isOwner(partnerId)
                    && request.resource.data.diff(resource.data)
                        .affectedKeys()
                        .hasOnly(['lastLogin', 'lastPasswordChange', 'firstLoginCompleted', 'requiresPasswordChange', 'passwordChangedAt', 'initialPassword']);
    }

    // ============================================
    // CHAT NOTIFICATIONS (Global + Multi-Tenant)
    // üÜï PHASE 2.3.3: Chat Notification Rules
    // ============================================

    // Global Chat Notifications
    match /chatNotifications/{docId} {
      allow read, write: if isAdmin();
      allow read: if isMitarbeiter() && isActive();
    }

    // Werkstatt-specific Chat Notifications: chatNotifications_mosbach, etc.
    match /{chatCollection}/{docId} {
      allow read, write: if chatCollection.matches('chatNotifications_.*') && isAdmin();
      allow read: if chatCollection.matches('chatNotifications_.*') && isMitarbeiter() && isActive();
    }

    // ============================================
    // PARTNER ANFRAGEN (global collection - DEPRECATED)
    // ‚ö†Ô∏è Kept for backward compatibility - use partnerAnfragen_{werkstatt} instead
    // ============================================

    match /partnerAnfragen/{anfrageId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access
      allow read, write: if (isMitarbeiter() && isActive());

      // Partners: Can create and read their own
      allow create: if isPartner() && isActive();
      allow read: if isPartner() && isActive() && isOwner(resource.data.partnerId);

      // Subcollection: Chat Messages
      match /chat/{messageId} {
        // Admins: Full access
        allow read, write: if isAdmin();

        // Mitarbeiter: Full access (read + write)
        allow read, write: if isMitarbeiter() && isActive();

        // Partner: Can read/write messages in their own anfragen
        allow read, write: if isPartner() && isActive()
                           && isOwner(get(/databases/$(database)/documents/partnerAnfragen/$(anfrageId)).data.partnerId);

        // Kunde: Read-only access to messages in their anfragen
        allow read: if isKunde() && isActive()
                    && isOwner(get(/databases/$(database)/documents/partnerAnfragen/$(anfrageId)).data.partnerId);
      }
    }

    // ============================================
    // PARTNER ANFRAGEN MULTI-TENANT (werkstatt-specific collections) üÜï
    // Using wildcard pattern: partnerAnfragen_mosbach, partnerAnfragen_heilbronn, etc.
    // ============================================

    match /{anfrageCollection}/{anfrageId} {
      // Admins: Full access to all werkst√§tten anfragen
      allow read, write: if anfrageCollection.matches('partnerAnfragen_.*')
                         && (isAdmin());

      // Mitarbeiter: Full access to werkstatt-specific anfragen
      allow read, write: if anfrageCollection.matches('partnerAnfragen_.*')
                         && ((isMitarbeiter() && isActive()));

      // Partners: Can create and read their own anfragen
      allow create: if anfrageCollection.matches('partnerAnfragen_.*')
                    && isPartner() && isActive();

      allow read: if anfrageCollection.matches('partnerAnfragen_.*')
                  && isPartner() && isActive()
                  && (
                    isOwner(resource.data.partnerId)  // Direct document reads by partnerId
                    || resource.data.partnerEmail == request.auth.token.email  // Queries by partnerEmail
                  );

      // üÜï BUGFIX 2025-11-06: Partners k√∂nnen ihre eigenen Anfragen updaten (f√ºr KVA-Annahme)
      // Security: Partner kann nur seine eigenen Anfragen updaten (partnerEmail match)
      allow update: if anfrageCollection.matches('partnerAnfragen_.*')
                    && isPartner()
                    && isActive()
                    && (
                      isOwner(resource.data.partnerId)
                      || resource.data.partnerEmail == request.auth.token.email
                    );

      // Subcollection: Chat Messages
      match /chat/{messageId} {
        // Admins: Full access
        allow read, write: if anfrageCollection.matches('partnerAnfragen_.*') && isAdmin();

        // Mitarbeiter: Full access
        allow read, write: if anfrageCollection.matches('partnerAnfragen_.*')
                           && isMitarbeiter() && isActive();

        // Partner: Can read/write messages in their own anfragen
        allow read, write: if anfrageCollection.matches('partnerAnfragen_.*')
                           && isPartner() && isActive()
                           && isOwner(get(/databases/$(database)/documents/$(anfrageCollection)/$(anfrageId)).data.partnerId);
      }
    }

    // ============================================
    // MITARBEITER NOTIFICATIONS MULTI-TENANT (werkstatt-specific notifications)
    // Using wildcard pattern: mitarbeiterNotifications_mosbach, etc.
    // ============================================

    match /{notificationsCollection}/{notificationId} {
      // Admins: Full access to all werkst√§tten notifications
      allow read, write: if notificationsCollection.matches('mitarbeiterNotifications_.*') && isAdmin();

      // Mitarbeiter: Can read and update their own notifications
      // Read: All notifications for this employee
      // Update: Mark as read, archive, etc.
      allow read: if notificationsCollection.matches('mitarbeiterNotifications_.*')
                  && isMitarbeiter() && isActive()
                  && resource.data.mitarbeiterId == request.auth.uid;

      allow update: if notificationsCollection.matches('mitarbeiterNotifications_.*')
                    && isMitarbeiter() && isActive()
                    && resource.data.mitarbeiterId == request.auth.uid
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'readAt']);

      // Cloud Functions: Can create new notifications (no auth context)
      // IMPORTANT: Cloud Functions run without authentication context
      allow create: if notificationsCollection.matches('mitarbeiterNotifications_.*'); // Cloud Functions will validate

      // Delete: Only admins (cleanup old notifications)
      allow delete: if notificationsCollection.matches('mitarbeiterNotifications_.*') && isAdmin();
    }

    // ============================================
    // BONUS AUSZAHLUNGEN (Global + Multi-Tenant)
    // üÜï BUGFIX 2025-11-04 (FIX #21): Security Rules f√ºr Partner-Bonus-Auszahlungen
    // Collections: bonusAuszahlungen (global) + bonusAuszahlungen_mosbach (tenant)
    // ============================================

    // Global Collection (legacy - f√ºr existierende Daten)
    match /bonusAuszahlungen/{bonusId} {
      // Admins: Full access
      allow read, write: if isAdmin();

      // Mitarbeiter: Read access (k√∂nnen alle Bonuses sehen)
      allow read: if isMitarbeiter() && isActive();

      // üÜï BUGFIX 2025-11-04 (FIX #26): Partners - Email-basiert mit Cross-Collection Fallback
      // üÜï BUGFIX 2025-11-04 (FIX #26, #33): Partners - Email-basiert (vereinfacht)
      // Removed komplexen Cross-Collection Fallback der zu Permission Errors f√ºhrte
      allow read: if request.auth != null
                  && resource.data.partnerEmail == request.auth.token.email;
    }

    // üî• BONUS RULES MOVED TO TOP (after helper functions) - See Line 63
    // This section was relocated to prevent pattern collision with other wildcard rules

    // ============================================
    // COLLECTION GROUP: chat (ALL chat subcollections)
    // Needed for global-chat-notifications.js db.collectionGroup('chat')
    // ============================================

    match /{path=**}/chat/{messageId} {
      // Admins: Full access to all chat messages across all collections
      allow read, write: if isAdmin();

      // Mitarbeiter: Full access (read + write) to all chat messages
      allow read, write: if isMitarbeiter() && isActive();

      // Partner: DISABLED for collectionGroup queries (too complex ownership check)
      // üÜï FIX: Partners must use direct subcollection queries, NOT collectionGroup
      // They can access chat via: partnerAnfragen_mosbach/{anfrageId}/chat/{messageId}
      // The ownership check happens at partnerAnfragen level (line 423-427)
      // allow read, write: if isPartner() && isActive();  // DISABLED - use direct queries instead

      // Kunden: Can read/write messages in anfragen where they are the customer
      // NOTE: This relies on subcollection rules for ownership check
      allow read, write: if isKunde() && isActive();
    }

    // ============================================
    // CHAT SUBCOLLECTIONS (CollectionGroup Query)
    // ============================================

    // Chat messages in Partner-Anfragen (partnerAnfragen_*/*/chat/*)
    match /{path=**}/chat/{messageId} {
      // Admins & Werkstatt: Can read all chat messages
      allow read: if isAdmin();

      // Mitarbeiter: Can read all chat messages
      allow read: if isMitarbeiter();

      // Partners: Can read/write messages in their own anfragen
      // Note: Ownership check via parent partnerAnfragen document
      allow read, write: if isPartner() && isActive();

      // Kunden: Can read/write messages in anfragen where they are the customer
      allow read, write: if isKunde() && isActive();
    }

    // ============================================
    // PARTNER AUTO-LOGIN TOKENS (Cloud Functions only)
    // ============================================

    match /partnerAutoLoginTokens/{tokenId} {
      // ONLY Cloud Functions can read/write tokens
      // Partners should NOT have direct access (security: tokens are one-time use)
      allow read, write: if false;
    }

    // ============================================
    // AUDIT_LOGS COLLECTION
    // ============================================

    match /audit_logs/{logId} {
      // Admins can read audit logs
      allow read: if isAdmin();

      // Allow authenticated users to create audit logs (for setup-werkstatt.html)
      allow create: if isAuthenticated();

      // Only admins can write/update/delete
      allow write: if isAdmin();
    }

    // ============================================
    // ZEITERFASSUNG COLLECTION (Time Tracking)
    // ============================================
    // Multi-tenant pattern: zeiterfassung_mosbach, zeiterfassung_heidelberg, etc.
    //
    // Stores daily time tracking records for employees:
    // - Clock in/out timestamps
    // - Break start/end timestamps
    // - Calculated actual working hours (IST-Zeit)
    //
    // Document ID format: {datum}_{mitarbeiterId} (e.g., "2025-11-08_user_1762559835944")
    //
    // Security:
    // - Employees can create/read/update ONLY their own records
    // - Admins can read ALL records
    // - Records locked after status = "completed" (no more edits)

    match /{zeiterfassungCollection}/{zeitId} {
      // ============================================
      // READ Rules
      // ============================================

      // Admins can read all time tracking records
      allow read: if zeiterfassungCollection.matches('zeiterfassung_.*')
                  && isAdmin();

      // Employees can read ONLY their own records
      allow read: if zeiterfassungCollection.matches('zeiterfassung_.*')
                  && isAuthenticated()
                  && request.auth.token.selectedMitarbeiterId != null
                  && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                  && resource.data.werkstattId == zeiterfassungCollection.split('_')[1];

      // ============================================
      // CREATE Rules
      // ============================================

      // Employees can create ONLY their own time tracking record
      allow create: if zeiterfassungCollection.matches('zeiterfassung_.*')
                    && isAuthenticated()
                    && request.auth.token.selectedMitarbeiterId != null
                    && request.resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && request.resource.data.werkstattId == zeiterfassungCollection.split('_')[1]
                    && request.resource.data.datum is string
                    && request.resource.data.events is list
                    && request.resource.data.status in ['in_progress', 'completed'];

      // ============================================
      // UPDATE Rules
      // ============================================

      // Employees can update ONLY their own records AND only if status != "completed"
      allow update: if zeiterfassungCollection.matches('zeiterfassung_.*')
                    && isAuthenticated()
                    && request.auth.token.selectedMitarbeiterId != null
                    && resource.data.mitarbeiterId == request.auth.token.selectedMitarbeiterId
                    && resource.data.werkstattId == zeiterfassungCollection.split('_')[1]
                    && resource.data.status != 'completed'  // Can't edit completed records
                    && request.resource.data.mitarbeiterId == resource.data.mitarbeiterId  // Can't change owner
                    && request.resource.data.datum == resource.data.datum;  // Can't change date

      // Admins can always update (e.g., to fix mistakes)
      allow update: if zeiterfassungCollection.matches('zeiterfassung_.*')
                    && isAdmin();

      // ============================================
      // DELETE Rules
      // ============================================

      // Only admins can delete time tracking records
      allow delete: if zeiterfassungCollection.matches('zeiterfassung_.*')
                    && isAdmin();
    }

    // ============================================
    // DEFAULT DENY - REMOVED (FIX #52)
    // ============================================

    // üêõ BUGFIX 2025-11-05: Removed global deny rule that was blocking ALL writes
    //
    // Previous code (REMOVED):
    //   match /{document=**} {
    //     allow read, write: if false;
    //   }
    //
    // Problem: This wildcard pattern matched EVERY path (including bonusAuszahlungen_mosbach)
    //          and created an explicit DENY that overrode ALL allow rules!
    //          Even "allow create: if true" failed because the global deny took precedence.
    //
    // Solution: Removed entirely - Firebase denies by default for unmatched paths.
    //           Specific rules above handle all authorized access.
  }
}
